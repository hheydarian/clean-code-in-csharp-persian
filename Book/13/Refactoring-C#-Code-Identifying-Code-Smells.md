# فصل سیزدهم:  بازآرایی کدهای C# – شناسایی Code Smellها 🎯

#### شناسایی Code Smellها

در این فصل، ما به بررسی کدهای مشکل‌دار و روش بازآرایی (Refactoring) آن‌ها می‌پردازیم. در صنعت نرم‌افزار، به چنین کدهایی اصطلاحاً **Code Smell** گفته می‌شود. این نوع کدها **کامپایل می‌شوند، اجرا می‌شوند و همان کاری را انجام می‌دهند که قرار است انجام دهند**، اما مشکل آن‌ها این است که به مرور زمان **خوانایی خود را از دست می‌دهند، پیچیده می‌شوند و نگهداری و توسعه آن‌ها دشوار می‌گردد**.

چنین کدهایی باید در اولین فرصت بازآرایی شوند. در غیر این صورت، این مشکل به‌عنوان **بدهی فنی (Technical Debt)** باقی می‌ماند و در طولانی‌مدت می‌تواند پروژه را به نقطه شکست برساند، به‌طوری که مجبور شوید **کل برنامه را از ابتدا طراحی و پیاده‌سازی کنید** که هزینه‌بر خواهد بود.

**بازآرایی (Refactoring)** چیست؟
بازآرایی فرایند **بازنویسی کد موجودی است که کار می‌کند**، اما هدف این است که کد **تمیزتر و بهتر** شود. همان‌طور که پیش‌تر دیدید، **کد تمیز (Clean Code)** به‌راحتی **خوانده می‌شود، نگهداری می‌شود و توسعه پیدا می‌کند**.

در این فصل به موارد زیر خواهیم پرداخت:

* شناسایی **Code Smellهای سطح برنامه (Application-level)** و روش‌های رفع آن‌ها
* شناسایی **Code Smellهای سطح کلاس (Class-level)** و روش‌های رفع آن‌ها
* شناسایی **Code Smellهای سطح متد (Method-level)** و روش‌های رفع آن‌ها

پس از مطالعه این فصل، مهارت‌های زیر را به دست خواهید آورد:

* توانایی شناسایی انواع مختلف **Code Smellها**
* درک این موضوع که چرا کد به‌عنوان Code Smell طبقه‌بندی شده است
* توانایی بازآرایی Code Smellها و تبدیل آن‌ها به **کد تمیز**

ما بررسی خود را با **Code Smellهای سطح برنامه** آغاز می‌کنیم.

---

### الزامات فنی 🛠️

برای این فصل به ابزارها و پیش‌نیازهای زیر احتیاج دارید:

* **Visual Studio 2019**
* **PostSharp**
* کدهای این فصل از طریق این لینک در دسترس است:
  [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH13](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH13)

---

### Code Smellهای سطح برنامه

**Code Smellهای سطح برنامه** کدهای مشکل‌داری هستند که در **تمام بخش‌های برنامه پراکنده‌اند** و بر **تمام لایه‌ها** تأثیر می‌گذارند. فرقی نمی‌کند در کدام لایه از نرم‌افزار باشید؛ این مشکلات را بارها و بارها خواهید دید.

اگر این مشکلات را همین حالا برطرف نکنید، نرم‌افزار شما به مرور زمان **دچار افت عملکرد شده و به سمت شکست پیش می‌رود**.

در این بخش، به **Code Smellهای سطح برنامه** و روش‌های رفع آن‌ها می‌پردازیم. با **Boolean Blindness** شروع می‌کنیم.

---

### Boolean Blindness (کوری بولیانی) 👀

**کوری بولیانی** به معنای **از دست رفتن اطلاعات** در متدها یا توابعی است که با مقادیر **Boolean (true/false)** کار می‌کنند.
استفاده از ساختارهای بهتر، **رابط‌ها و کلاس‌هایی با وضوح بالاتر** ایجاد می‌کند که داده‌ها را واضح‌تر نگه می‌دارند و تجربه کاری بهتری فراهم می‌کنند.

بیایید این مشکل را با یک مثال بررسی کنیم:

```csharp
public void BookConcert(string concert, bool standing)
{
    if (standing)
    {
        // Issue standing ticket.
    }
    else
    {
        // Issue sitting ticket.
    }
}
```

این متد یک **string** برای نام کنسرت و یک **Boolean** برای مشخص کردن اینکه فرد **ایستاده یا نشسته** است، دریافت می‌کند. حالا این کد به این صورت فراخوانی می‌شود:

```csharp
private void BooleanBlindnessConcertBooking()
{
    var booking = new ProblemCode.ConcertBooking();
    booking.BookConcert("Solitary Experiments", true);
}
```

اگر شخصی تازه‌وارد به این کد نگاه کند، آیا می‌تواند به‌صورت غریزی متوجه شود که **true** به چه معناست؟ مسلماً نه.
او برای فهمیدن موضوع مجبور است یا از **IntelliSense** استفاده کند یا **به متد اصلی مراجعه کند**.
این همان **کوری بولیانی** است.

راه‌حل چیست؟
یک راه‌حل ساده این است که **به جای Boolean از enum استفاده کنیم**.

ابتدا **enum** خود را ایجاد می‌کنیم:

```csharp
[Flags]
internal enum TicketType
{
    Seated,
    Standing
}
```

این enum دو نوع بلیط را مشخص می‌کند: **Seated (نشسته)** و **Standing (ایستاده)**.

حالا متد **BookConcert()** خود را بازآرایی می‌کنیم:

```csharp
internal void BookConcert(string concert, TicketType ticketType)
{
    if (ticketType == TicketType.Seated)
    {
        // Issue seated ticket.
    }
    else
    {
        // Issue standing ticket.
    }
}
```

و حالا به این صورت فراخوانی می‌کنیم:

```csharp
private void ClearSightedConcertBooking()
{
    var booking = new RefactoredCode.ConcertBooking();
    booking.BookConcert("Chrom", TicketType.Seated);
}
```

در این حالت، اگر شخص جدیدی به کد نگاه کند، فوراً متوجه می‌شود که **در حال رزرو بلیط نشسته برای کنسرت گروه Chrom هستیم**.

### 💥 انفجار ترکیبی (Combinatorial Explosion)

انفجار ترکیبی، نتیجه‌ی اجرای یک عمل مشابه توسط قسمت‌های مختلف کد، اما با ترکیب‌های متفاوتی از پارامترها است. بیایید به یک مثال که اعداد را جمع می‌کند نگاه کنیم:

```csharp
public int Add(int x, int y)
{
    return x + y;
}
public double Add(double x, double y)
{
    return x + y;
}
public float Add(float x, float y)
{
    return x + y;
}
```

در اینجا، ما سه متد داریم که همگی عملیات جمع را انجام می‌دهند، اما **نوع داده‌ی بازگشتی (return type)** و **پارامترها** متفاوت هستند. آیا راه بهتری وجود دارد؟ بله ✅، با استفاده از **Generics (جنریک‌ها)**. با کمک جنریک‌ها، شما می‌توانید تنها **یک متد** داشته باشید که قادر به کار کردن با انواع داده‌های مختلف است. پس ما از جنریک‌ها برای حل مسئله جمع استفاده می‌کنیم. این کار به ما اجازه می‌دهد یک متد واحد داشته باشیم که **عدد صحیح (int)**، **عدد اعشاری (double)** یا **عدد اعشاری با دقت کمتر (float)** را بپذیرد. بیایید به متد جدید نگاه کنیم:

```csharp
public T Add<T>(T x, T y)
{
    dynamic a = x;
    dynamic b = y;
    return a + b;
}
```

این متد جنریک با یک نوع مشخص برای **T** فراخوانی می‌شود. عملیات جمع را انجام می‌دهد و نتیجه را بازمی‌گرداند. فقط **یک نسخه از متد** برای انواع مختلف داده‌های **.NET** که امکان جمع شدن دارند کافی است. برای فراخوانی این کد با مقادیر int، double و float، به این صورت عمل می‌کنیم:

```csharp
var addition = new RefactoredCode.Maths();
addition.Add<int>(1, 2);
addition.Add<double>(1.2, 3.4);
addition.Add<float>(5.6f, 7.8f);
```

ما به‌تازگی **سه متد** را حذف کرده و جایگزین آن‌ها را **یک متد واحد** کرده‌ایم که همان وظیفه را انجام می‌دهد. 🎯

---

### 🧩 پیچیدگی ساختگی (Contrived Complexity)

زمانی که می‌توانید کدی با **معماری ساده** پیاده‌سازی کنید، اما به‌جای آن یک معماری پیشرفته و نسبتاً پیچیده اجرا می‌کنید، به آن **پیچیدگی ساختگی** می‌گویند. متأسفانه، من شخصاً مجبور به کار روی چنین سیستم‌هایی بوده‌ام و باید بگویم **این موضوع واقعاً دردسرساز و استرس‌آور است**.

در چنین سیستم‌هایی معمولاً اتفاقات زیر رخ می‌دهد:

* **نرخ جابجایی نیروها بالا است.**
* **مستندات کافی وجود ندارد.**
* **هیچ‌کس به‌طور کامل سیستم را نمی‌شناسد و کسی پاسخگوی سؤالات افراد جدید نیست.**

👨‍💻 **توصیه من به همه معماران نرم‌افزار فوق‌هوشمند این است:**
**Keep It Simple, Stupid (KISS)** – «ساده نگه‌دار، احمقانه».

به خاطر داشته باشید که دوران استخدام‌های دائمی و شغل‌های مادام‌العمر دیگر کمتر شده است. امروزه بسیاری از برنامه‌نویسان به‌دنبال **درآمد بیشتر** هستند تا **وفاداری طولانی‌مدت به کسب‌وکار**. بنابراین، با توجه به اینکه **درآمد شرکت به نرم‌افزار وابسته است**، باید سیستمی داشته باشید که:

* به‌راحتی قابل درک باشد.
* نیروی جدید بتواند سریعاً وارد کار شود.
* نگهداری و توسعه‌ی آن آسان باشد.

از خودتان بپرسید:

* **اگر شما و تیم‌تان ناگهان شرکت را ترک کنید، آیا تیم جدید می‌تواند به‌سرعت کار را ادامه دهد؟ یا کاملاً سردرگم خواهد شد؟**
* **اگر تنها فردی که سیستم را می‌شناسد فوت کند، مهاجرت کند یا بازنشسته شود، تکلیف تیم و کسب‌وکار چه می‌شود؟**

من نمی‌توانم به اندازه کافی بر اهمیت **KISS** تأکید کنم. تنها دلیلی که برخی افراد سیستم‌های پیچیده و بدون مستندات می‌سازند، **وابسته کردن کسب‌وکار به خودشان** است. این کار اشتباه است. تجربه من نشان داده که **هرچه سیستم پیچیده‌تر باشد، سریع‌تر شکست می‌خورد و نیاز به بازنویسی دارد**. ❌

---

### 🛠 کاهش پیچیدگی و بهبود کیفیت کد

در **فصل ۱۲ (Using Tools to Improve Code Quality)** یاد گرفتید که چگونه از ابزارهای **Visual Studio 2019** برای کشف **Cyclomatic Complexity** و **Depth of Inheritance** استفاده کنید. همچنین یاد گرفتید چگونه **نمودار وابستگی (Dependency Diagram)** با استفاده از **ReSharper** تولید کنید.

از این ابزارها برای پیدا کردن **بخش‌های مشکل‌دار** در کد استفاده کنید و روی آن‌ها تمرکز کنید:

* **پیچیدگی حلقوی را به ۱۰ یا کمتر کاهش دهید.**
* **عمق ارث‌بری تمام اشیا را به حداکثر ۱ برسانید.**
* **هر کلاس فقط وظایفی را انجام دهد که برای آن طراحی شده است.**
* **متدها را کوچک نگه دارید (به‌طور متوسط حدود ۱۰ خط کد).**
* **لیست‌های طولانی پارامترها را با اشیای پارامتر جایگزین کنید.**
* **اگر پارامترهای خروجی زیادی دارید، متد را طوری بازنویسی کنید که یک Tuple یا یک شیء برگرداند.**
* **در موارد چندنخی (Multithreading)، اطمینان حاصل کنید که کد Thread-safe باشد.**
* **از اشیای Immutable به جای Mutable استفاده کنید.**

همچنین به **آیکون‌های Quick Tips** توجه کنید. این آیکون‌ها معمولاً پیشنهادهای **Refactoring یک‌کلیکی** برای خط کد موردنظر ارائه می‌دهند. توصیه می‌کنم از آن‌ها استفاده کنید.

---

### 📦 توده داده (Data Clump)

**توده داده** زمانی رخ می‌دهد که **فیلدهای مشابه** را در کلاس‌های مختلف و لیست پارامترها می‌بینید که معمولاً الگوی نام‌گذاری مشابهی دارند. این معمولاً نشانه‌ی این است که **یک کلاس در سیستم وجود ندارد**. کاهش پیچیدگی سیستم با **شناسایی کلاس گمشده و عمومی‌سازی آن** به‌دست می‌آید.

از کوچک بودن کلاس نترسید و هیچ‌وقت فکر نکنید که یک کلاس کوچک بی‌اهمیت است. اگر برای ساده‌سازی کد به یک کلاس نیاز دارید، **آن را اضافه کنید.** ✨

### **کامنت‌های خوشبوکننده (Deodorant Comments)** 📝

وقتی یک کامنت با جملات زیبا و مثبت سعی دارد کدی ضعیف یا بد را توجیه کند، به آن **کامنت خوشبوکننده** گفته می‌شود. ❌ اگر کد بد است، باید **بازآرایی (Refactor)** شود تا خوب شود و سپس کامنت حذف شود. اگر نمی‌دانید چگونه بازآرایی کنید، از دیگران کمک بگیرید. اگر کسی برای کمک در دسترس نیست، **کد خود را در Stack Overflow** قرار دهید. برنامه‌نویسان بسیار ماهری در آن سایت هستند که می‌توانند به شما کمک کنند، فقط قوانین انتشار را رعایت کنید!

---

### **کد تکراری (Duplicate Code)** 🔁

کد تکراری، کدی است که **بیش از یک‌بار در پروژه ظاهر شده است**. مشکلاتی که از تکرار کد به‌وجود می‌آیند:

* **هزینه نگهداری بالا**: هر بار که اشکالی در کد رفع می‌کنید، زمان و هزینه صرف می‌شود.

  * یک باگ = هزینه × ۱
  * همان باگ در ۱۰ جای دیگر = هزینه × ۱۰
* **خستگی و ملال برنامه‌نویس** هنگام اصلاح یک مشکل در چند نقطه مختلف.
* **احتمال از قلم افتادن برخی از تکرارها** در زمان رفع اشکال.

راه‌حل چیست؟ **بازآرایی کد برای حذف تکرارها**. ساده‌ترین روش، **انتقال کد به یک کلاس جدید قابل‌استفاده مجدد** در پروژه است.

مزیت دیگر این است که می‌توانید **کدهای قابل‌استفاده مجدد را در یک کتابخانه (Class Library)** قرار دهید تا سایر پروژه‌ها هم از آن بهره ببرند.
امروزه **بهترین انتخاب، استفاده از کتابخانه‌های .NET Standard** است، چون این کتابخانه‌ها در تمامی پلتفرم‌ها در دسترس‌اند: **Windows، Linux، macOS، iOS و Android**.

روش‌های دیگر برای کاهش کدهای تکراری:

* **برنامه‌نویسی جنبه‌گرا (Aspect-Oriented Programming – AOP)**: در این روش، کدهای تکراری به یک **Aspect** منتقل می‌شوند و هنگام کامپایل به کد اصلی اضافه می‌گردند. در نتیجه، متد فقط شامل منطق تجاری است و کدهای جانبی پنهان می‌مانند.
* **الگوی دکوراتور (Decorator Pattern)**: همان‌طور که در فصل قبل دیدید، این الگو می‌تواند عملیات یک کلاس را تزئین کند و امکان اضافه کردن رفتار جدید بدون تغییر در کد اصلی را فراهم می‌کند. مثال ساده: **پیچیدن عملیات در یک بلوک try/catch** که در فصل 11 توضیح داده شد.

---

### **از دست رفتن هدف یا نیت (Lost Intent)** ❓

وقتی نتوانید **به‌راحتی هدف یا مقصود کد را درک کنید**، یعنی نیت کد از بین رفته است.

گام‌ها برای رفع این مشکل:

1. **بررسی فضای نام (Namespace) و نام کلاس**: باید هدف کلاس را نشان دهد.
2. **بررسی محتوای کلاس**: به‌دنبال کدی باشید که در جای نامناسبی قرار دارد. آن‌ها را شناسایی و به جای درست منتقل کنید.
3. **بررسی متدها**:

   * آیا هر متد فقط یک کار را به‌خوبی انجام می‌دهد یا چند کار را نه‌چندان خوب؟
   * اگر پاسخ دوم است، بازآرایی کنید.
   * در متدهای بزرگ، کدهای قابل‌استخراج را به متدهای کوچک‌تر منتقل کنید.

**هدف نهایی**: کد کلاس باید **مثل یک کتاب خوانا** باشد. بازآرایی کنید تا نیت کد شفاف شود و هر کلاس فقط کاری را انجام دهد که برای آن طراحی شده است.

**نکته:** ابزارهای معرفی‌شده در **فصل 12 (استفاده از ابزارها برای بهبود کیفیت کد)** را فراموش نکنید.

مبحث بعدی: **بوی بد کد – تغییرات مکرر متغیرها (Mutation of Variables)** خواهد بود.

### **تغییرات مکرر متغیرها (The Mutation of Variables)** 🔄

تغییرات مکرر متغیرها یعنی **متغیرها به‌گونه‌ای هستند که فهمیدن و استدلال درباره‌ی آن‌ها دشوار است**. این باعث می‌شود که بازآرایی (Refactor) آن‌ها سخت شود.

یک **متغیر قابل تغییر (Mutable Variable)**، متغیری است که **چندین بار توسط عملیات مختلف تغییر می‌کند**. این مسئله استدلال درباره‌ی دلیل تغییر مقدار متغیر را دشوار می‌کند. علاوه بر این، چون متغیر توسط عملیات مختلف تغییر می‌کند، **استخراج بخش‌هایی از کد به متدهای کوچک‌تر و خواناتر** نیز سخت‌تر می‌شود. همچنین، متغیرهای قابل تغییر ممکن است نیازمند بررسی‌های بیشتری باشند که **پیچیدگی کد** را افزایش می‌دهد.

#### راهکارها:

* بخش‌های کوچک کد را **به متدهای جداگانه استخراج کنید**.
* اگر کد شامل **انشعاب‌ها و حلقه‌های متعدد** است، ببینید آیا راه ساده‌تری برای کاهش پیچیدگی وجود دارد یا خیر.
* اگر از چندین **مقدار out** استفاده می‌کنید، در نظر بگیرید که **یک شیء یا Tuple** برگردانید.
* هدف این است که **قابلیت تغییر متغیر را کاهش دهید** تا بتوان راحت‌تر درباره‌ی آن استدلال کرد، بدانید مقدار متغیر از کجا می‌آید و چرا آن مقدار را دارد.
* هرچه متد کوچک‌تر باشد، **تشخیص محل و دلیل تنظیم متغیر آسان‌تر** است.

---

#### مثال عملی:

```csharp
[InstrumentationAspect]
public class Mutant
{
    public int IntegerSquaredSum(List<int> integers)
    {
        var squaredSum = 0;
        foreach (var integer in integers)
        {
            squaredSum += integer * integer;
        }
        return squaredSum;
    }
}
```

این متد، یک **لیست از اعداد صحیح (integers)** دریافت می‌کند، سپس روی هر عدد حلقه می‌زند، مربع آن را محاسبه و به متغیر `squaredSum` اضافه می‌کند. توجه کنید که **در هر تکرار حلقه، مقدار متغیر محلی تغییر می‌کند**.

---

#### نسخه بازآرایی شده و بهبود یافته با LINQ:

```csharp
[InstrumentationAspect]
public class Function
{
    public int IntegerSquaredSum(List<int> integers)
    {
        return integers.Sum(integer => integer * integer);
    }
}
```

در نسخه جدید، از **LINQ** استفاده شده است. همان‌طور که در فصل‌های قبل یاد گرفتید، LINQ از **برنامه‌نویسی تابعی (Functional Programming)** بهره می‌برد.
همان‌طور که می‌بینید:

* **هیچ حلقه‌ای وجود ندارد**
* **هیچ متغیر محلی در حال تغییر نیست**

با کامپایل و اجرای برنامه، خروجی مشابه نسخه قبلی خواهد بود، اما **کد ساده‌تر، خواناتر و بدون تغییر مکرر متغیر** است.
