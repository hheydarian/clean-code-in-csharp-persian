# ۱
# استانداردهای کدنویسی و اصول در سی‌شارپ

هدف اصلی استانداردهای کدنویسی و اصول در C# این است که برنامه‌نویسان با تولید کدی که هم عملکرد بهتری دارد و هم نگهداری آن آسان‌تر است، در حرفه خود ارتقا یابند. در این فصل، به بررسی نمونه‌هایی از کدهای خوب در مقابل کدهای بد خواهیم پرداخت. این موضوع ما را به بحث درباره اینکه چرا به استانداردهای کدنویسی، اصول و متدولوژی‌ها نیاز داریم، سوق می‌دهد. سپس به بررسی قراردادهای نام‌گذاری، کامنت‌گذاری و فرمت‌بندی کد منبع، شامل کلاس‌ها، متدها و متغیرها خواهیم پرداخت.

یک برنامه بزرگ می‌تواند برای درک و نگهداری بسیار پیچیده و دشوار باشد. برای برنامه‌نویسان تازه‌کار، شناخت کد و درک عملکرد آن می‌تواند چشم‌اندازی دلهره‌آور باشد. تیم‌ها ممکن است در کار گروهی روی چنین پروژه‌هایی با مشکل مواجه شوند. و از دیدگاه تست، می‌تواند کارها را بسیار دشوار کند. به همین دلیل، بررسی خواهیم کرد که چگونه از ماژولار بودن (modularity) استفاده می‌کنید تا برنامه‌ها را به ماژول‌های کوچک‌تر تقسیم کنید که همگی با هم کار می‌کنند تا یک راه‌حل کاملاً کارآمد و قابل تست را ارائه دهند، که می‌تواند به صورت همزمان توسط چندین تیم روی آن کار شود و خواندن، درک و مستندسازی آن بسیار آسان‌تر است.

در پایان این فصل، به بررسی برخی از دستورالعمل‌های طراحی برنامه‌نویسی، شامل KISS، YAGNI، DRY، SOLID و تیغ اوکام (Occam's Razor) خواهیم پرداخت.

#### استانداردهای کدنویسی و اصول در سی‌شارپ

فصل ۱

مباحث زیر در این فصل پوشش داده خواهند شد:

+ نیاز به استانداردهای کدنویسی، اصول و متدولوژی‌ها

+ قراردادهای نام‌گذاری و متدها

+ کامنت‌ها و فرمت‌بندی

+ ماژولار بودن

+ KISS

+ YAGNI

+ DRY

+ SOLID

+ تیغ اوکام (Occam's Razor)

 اهداف یادگیری شما برای این فصل به شرح زیر است:

+ درک اینکه چرا کدهای بد تأثیر منفی بر پروژه‌ها می‌گذارند.

+ درک اینکه چگونه کدهای خوب تأثیر مثبتی بر پروژه‌ها دارند.

+ درک اینکه چگونه استانداردهای کدنویسی کیفیت کد را بهبود می‌بخشند و چگونه آنها را اعمال کنید.

+ درک اینکه چگونه اصول کدنویسی کیفیت نرم‌افزار را ارتقا می‌دهند.

+ درک اینکه چگونه متدولوژی‌ها به توسعه کدهای تمیز کمک می‌کنند.

+ پیاده‌سازی استانداردهای کدنویسی.

+ انتخاب راه‌حل‌هایی با کمترین فرضیات ممکن.

+ کاهش تکرار کد و نوشتن کد SOLID.

## الزامات فنی
برای کار بر روی کدهای این فصل، باید Visual Studio 2019 Community Edition یا نسخه‌های بالاتر را دانلود و نصب کنید. این IDE را می‌توانید از https://visualstudio.microsoft.com/ دانلود کنید.

کدهای این کتاب در https://github.com/PacktPublishing/Clean-Code-in-C- قرار دارند. من همه آنها را در یک solution واحد با هر فصل به عنوان یک پوشه solution قرار داده‌ام. کدهای مربوط به هر فصل را در پوشه فصل مربوطه پیدا خواهید کرد. اگر پروژه‌ای را اجرا می‌کنید، به یاد داشته باشید که آن را به عنوان پروژه Startup تعیین کنید.

## کد خوب در مقابل کد بد
هم کد خوب و هم کد بد کامپایل می‌شوند. این اولین چیزی است که باید درک کرد. نکته بعدی این است که کد بد به دلیلی بد است و به همین ترتیب، کد خوب نیز به دلیلی خوب است. بیایید در جدول مقایسه‌ای زیر به برخی از این دلایل نگاهی بیندازیم:

<div align="center">
  
  ![Conventions-UsedThis-Book](../../assets/image/01/Table%201-1.png) 
  
</div>

همینطور است! در بخش‌های بعدی، به این خواهیم پرداخت که چگونه این ویژگی‌ها و تفاوت‌های بین کدهای خوب و بد، بر عملکرد کد شما تأثیر می‌گذارند.

## کد بد
اکنون نگاهی اجمالی به هر یک از شیوه‌های کدنویسی بد که قبلاً فهرست کردیم خواهیم داشت و به طور خاص توضیح می‌دهیم که هر یک از این شیوه‌ها چگونه بر کد شما تأثیر می‌گذارند.

## تورفتگی نامناسب (Improper indentation)
تورفتگی نامناسب می‌تواند باعث شود خواندن کد واقعاً دشوار شود، به خصوص اگر متدها بزرگ باشند. برای اینکه کد برای انسان‌ها به راحتی قابل خواندن باشد، به تورفتگی مناسب نیاز داریم. اگر کد فاقد تورفتگی صحیح باشد، تشخیص اینکه کدام قسمت از کد متعلق به کدام بلوک است، بسیار دشوار خواهد بود.

به طور پیش‌فرض، Visual Studio 2019 کد شما را هنگام بسته شدن پرانتزها و براکت‌ها (آکولادها) به درستی فرمت و تورفتگی می‌دهد. اما گاهی اوقات، به اشتباه کد را فرمت می‌کند تا به شما هشدار دهد که کدی که نوشته‌اید حاوی یک استثنا است. اما اگر از یک ویرایشگر متن ساده استفاده می‌کنید، باید فرمت‌بندی خود را به صورت دستی انجام دهید.

کد دارای تورفتگی نادرست همچنین زمان‌بر برای تصحیح است و هدر دادن ناامیدکننده زمان برنامه‌نویسی است، در حالی که به راحتی می‌توان از آن اجتناب کرد. بیایید به یک مثال کد ساده نگاه کنیم:

```C#

public void DoSomething()
{
    for (var i = 0; i < 1000; i++)
    {
        var productCode = $"PRC000{i}";
        //...implementation
    }
}
```
کد بالا آنقدر هم خوب به نظر نمی‌رسد، با این حال هنوز قابل خواندن است. اما هرچه خطوط کد بیشتری اضافه کنید، خواندن کد دشوارتر می‌شود.

جا انداختن یک براکت بسته بسیار آسان است. اگر کد شما به درستی تورفتگی نداشته باشد، یافتن براکت گم‌شده بسیار دشوارتر می‌شود، زیرا نمی‌توانید به راحتی تشخیص دهید که کدام بلوک کد براکت بسته‌اش را گم کرده است.

## کامنت‌هایی که بدیهیات را بیان می‌کنند (Comments that state the obvious)
من دیده‌ام که برنامه‌نویسان واقعاً از کامنت‌هایی که بدیهیات را بیان می‌کنند عصبانی می‌شوند، زیرا آنها را تحقیرآمیز می‌دانند. در بحث‌های برنامه‌نویسی که من در آنها شرکت کرده‌ام، برنامه‌نویسان اظهار داشته‌اند که چقدر از کامنت‌ها بیزارند و چگونه معتقدند که کد باید خود-مستندساز (self-documenting) باشد.

من احساسات آنها را درک می‌کنم. اگر می‌توانید کد را بدون کامنت بخوانید، مانند زمانی که یک کتاب را می‌خوانید و آن را درک می‌کنید، پس آن یک قطعه کد واقعاً خوب است. اگر یک متغیر به عنوان رشته (string) اعلان شده است، پس چرا کامنتی مانند // string اضافه کنید؟ بیایید به یک مثال نگاه کنیم:

```C#

public int _value; // This is used for storing integer values.
```
در اینجا می‌دانیم که value یک عدد صحیح را توسط نوع int خود نگه می‌دارد. بنابراین واقعاً نیازی به بیان بدیهیات نیست. تنها کاری که انجام می‌دهید هدر دادن زمان و انرژی و شلوغ کردن کد است.

## کامنت‌هایی که کد بد را توجیه می‌کنند (Comments that excuse bad code)
ممکن است مهلت تنگی برای رسیدگی داشته باشید، اما کامنت‌هایی مانند // I know this code sucks but hey at least it works! واقعاً وحشتناک هستند. این کار را نکنید. این نشان‌دهنده عدم حرفه‌ای‌گری است و می‌تواند واقعاً باعث نارضایتی همکاران برنامه‌نویس شود.

اگر واقعاً برای اینکه چیزی را به سرعت کارساز کنید تحت فشار هستید، یک تیکت بازسازی (refactor ticket) ایجاد کنید و آن را به عنوان بخشی از یک کامنت TODO اضافه کنید، مانند // TODO: PBI23154 Refactor Code to meet company coding practices. سپس شما یا سایر توسعه‌دهندگانی که برای کار روی بدهی فنی (technical debt) تعیین شده‌اند، می‌توانند آن آیتم بک‌لاگ محصول (Product Backlog Item - PBI) را برداشته و کد را بازسازی (refactor) کنند.

در اینجا یک مثال دیگر آورده شده است:

```C#

...
int value = GetDataValue(); // This sometimes causes a divide by zero error. Don't know why!
...
```
این یکی واقعاً بد است. بسیار خب، از اینکه به ما اطلاع دادید خطاهای تقسیم بر صفر در اینجا رخ می‌دهند، متشکریم. اما آیا یک تیکت باگ (bug ticket) ایجاد کرده‌اید؟ آیا سعی کرده‌اید به ریشه مشکل برسید و آن را برطرف کنید؟ اگر هر کسی که فعالانه روی پروژه کار می‌کند به آن کد دست نزند، چگونه متوجه می‌شوند که کد مشکل‌دار در آنجا وجود دارد؟

در حداقل حالت، حداقل باید یک کامنت // TODO: در محل داشته باشید. سپس حداقل کامنت در لیست وظایف (Task List) ظاهر می‌شود تا توسعه‌دهندگان مطلع شده و روی آن کار کنند.

## خطوط کد کامنت‌شده (Commented-out lines of code)
اگر برای امتحان کردن چیزی، خطوط کد را کامنت می‌کنید (comment out)، اشکالی ندارد. اما اگر قصد دارید از کد جایگزین به جای کد کامنت‌شده استفاده کنید، قبل از اینکه آن را چک‌این کنید (check it in)، کد کامنت‌شده را حذف کنید. یک یا دو خط کامنت‌شده آنقدر هم بد نیست. اما وقتی خطوط زیادی از کد کامنت‌شده دارید، حواس‌پرتی ایجاد می‌کند و نگهداری کد را دشوار می‌کند؛ حتی می‌تواند منجر به سردرگمی شود:

```C#

/* No longer used as has been replaced by DoSomethinElse().
public void DoSomething()
{
    // ...implementation...
}
*/
```
چرا؟ فقط چرا؟ اگر جایگزین شده و دیگر مورد نیاز نیست، پس فقط آن را حذف کنید. اگر کد شما در سیستم کنترل نسخه (version control) است و نیاز دارید متد را برگردانید، همیشه می‌توانید تاریخچه فایل را مشاهده کرده و متد را برگردانید.

## سازماندهی نامناسب فضای نام‌ها (Improper organization of namespaces)
هنگام استفاده از فضاهای نام (namespaces)، کدهایی را که باید در جای دیگری باشند، در آن نگنجانید. این کار می‌تواند یافتن کد صحیح را به خصوص در پایگاه‌های کد بزرگ، بسیار دشوار یا غیرممکن کند. بیایید به این مثال نگاه کنیم:

```C#

namespace MyProject.TextFileMonitor
{
    + public class Program { ... }
    + public class DateTime { ... }
    + public class FileMonitorService { ... }
    + public class Cryptography { ... }
}
```
می‌بینیم که تمام کلاس‌های موجود در کد بالا تحت یک فضای نام قرار دارند. با این حال، ما این فرصت را داریم که سه فضای نام دیگر برای سازماندهی بهتر این کد اضافه کنیم:

+ MyProject.TextFileMonitor.Core: کلاس‌های هسته (Core) که اعضای متداول را تعریف می‌کنند، مانند کلاس DateTime ما، در اینجا قرار خواهند گرفت.

+ MyProject.TextFileMonitor.Services: تمام کلاس‌هایی که به عنوان سرویس عمل می‌کنند، مانند FileMonitorService، در این فضای نام قرار خواهند گرفت.

+ MyProject.TextFileMonitor.Security: تمام کلاس‌های مرتبط با امنیت، از جمله کلاس Cryptography در مثال ما، در این فضای نام قرار خواهند گرفت.


## قوانین نام‌گذاری بد (Bad naming conventions)
در دوران برنامه‌نویسی Visual Basic 6، از نشانه‌گذاری مجارستانی (Hungarian Notation) استفاده می‌کردیم. یادم می‌آید وقتی برای اولین بار به Visual Basic 1.0 تغییر برنامه دادم از آن استفاده می‌کردم. دیگر نیازی به استفاده از نشانه‌گذاری مجارستانی نیست. به علاوه، کد شما را زشت می‌کند. بنابراین به جای استفاده از نام‌هایی مانند lblName، txtName یا btnSave، روش مدرن استفاده از NameLabel، NameTextBox و SaveButton است.

استفاده از نام‌های مرموز و نام‌هایی که به نظر نمی‌رسد با هدف کد مطابقت داشته باشند، می‌تواند خواندن کد را نسبتاً دشوار کند. ihridx به چه معناست؟ به معنای Human Resources Index و یک عدد صحیح است. واقعاً! از استفاده از نام‌هایی مانند mystring، myint و mymethod خودداری کنید. چنین نام‌هایی واقعاً کاربردی ندارند.

همچنین از استفاده از آندرلاین بین کلمات در یک نام، مانند Bad_Programmer، خودداری کنید. این می‌تواند باعث فشار بصری برای توسعه‌دهندگان شود و خواندن کد را دشوار کند. کافیست آندرلاین را حذف کنید.

از یک قرارداد کدنویسی برای متغیرها در سطح کلاس و سطح متد استفاده نکنید. این می‌تواند تشخیص محدوده یک متغیر را دشوار کند. یک قرارداد خوب برای نام‌گذاری متغیرها استفاده از حالت شتری (camel case) برای نام متغیرها مانند alienSpawn، و حالت پاسکال (Pascal case) برای نام متد، کلاس، ساختار (struct) و اینترفیس (interface) مانند EnemySpawnGenerator است.

با پیروی از قرارداد نام‌گذاری متغیر خوب، باید بین متغیرهای محلی (local variables) (آنهایی که در یک سازنده یا متد قرار دارند) و متغیرهای عضو (member variables) (آنهایی که در بالای کلاس خارج از سازنده‌ها و متدها قرار می‌گیرند) با پیشوندگذاری متغیرهای عضو با یک آندرلاین تمایز قائل شوید. من از این به عنوان یک قرارداد کدنویسی در محل کار استفاده کرده‌ام و واقعاً خوب کار می‌کند و به نظر می‌رسد برنامه‌نویسان این قرارداد را دوست دارند.

## کلاس‌هایی که چندین کار انجام می‌دهند (Classes that do multiple jobs)
یک کلاس خوب باید فقط یک کار را انجام دهد. داشتن کلاسی که به پایگاه داده متصل می‌شود، داده‌ها را دریافت می‌کند، آن داده‌ها را دستکاری می‌کند، یک گزارش را بارگذاری می‌کند، داده‌ها را به گزارش اختصاص می‌دهد، گزارش را نمایش می‌دهد، گزارش را ذخیره می‌کند، گزارش‌ها را چاپ می‌کند و گزارش را اکسپورت می‌کند، کارهای زیادی انجام می‌دهد. باید آن را به کلاس‌های کوچک‌تر و بهتر سازمان‌یافته بازسازی (refactored) کرد. کلاس‌های جامع مانند این برای خواندن بسیار آزاردهنده هستند. من شخصاً آنها را دلهره‌آور می‌یابم. اگر با چنین کلاس‌هایی مواجه شدید، قابلیت‌ها را به بخش‌ها (regions) سازماندهی کنید. سپس کد موجود در آن بخش‌ها را به کلاس‌های جدیدی منتقل کنید که یک کار را انجام می‌دهند.

بیایید به مثالی از کلاسی که چندین کار را انجام می‌دهد نگاه کنیم:

```C#

public class DbAndFileManager
{
    #region Database Operations
    [ 13 ]
    Coding Standards and Principles in C#
    Chapter 1
    public void OpenDatabaseConnection() { throw new
        NotImplementedException(); }
    public void CloseDatabaseConnection() { throw new
        NotImplementedException(); }
    public int ExecuteSql(string sql) { throw new
        NotImplementedException(); }
    public SqlDataReader SelectSql(string sql) { throw new
        NotImplementedException(); }
    public int UpdateSql(string sql) { throw new
        NotImplementedException(); }
    public int DeleteSql(string sql) { throw new
        NotImplementedException(); }
    public int InsertSql(string sql) { throw new
        NotImplementedException(); }
    #endregion
    #region File Operations
    public string ReadText(string filename) { throw new
        NotImplementedException(); }
    public void WriteText(string filename, string text) { throw new
        NotImplementedException(); }
    public byte[] ReadFile(string filename) { throw new
        NotImplementedException(); }
    public void WriteFile(string filename, byte[] binaryData) { throw new
        NotImplementedException(); }
    #endregion
}
```
همانطور که در کد بالا می‌بینید، کلاس دو کار اصلی انجام می‌دهد: عملیات پایگاه داده و عملیات فایل را انجام می‌دهد. اکنون کد به طور مرتب در بخش‌های (regions) نام‌گذاری شده صحیح سازماندهی شده است که برای جداسازی منطقی کد در یک کلاس استفاده می‌شوند. اما اصل مسئولیت واحد (Single Responsibility Principle - SRP) نقض شده است. ما باید با بازسازی این کد شروع کنیم تا عملیات پایگاه داده را به کلاسی جداگانه، مانند DatabaseManager، منتقل کنیم.

سپس، عملیات پایگاه داده را از کلاس DbAndFileManager حذف می‌کنیم، فقط عملیات فایل را باقی می‌گذاریم و سپس کلاس DbAndFileManager را به FileManager تغییر نام می‌دهیم. همچنین باید فضای نام هر فایل را در نظر بگیریم و اینکه آیا باید تغییر کند تا DatabaseManager در فضای نام Data و FileManager در فضای نام FileSystem (یا معادل‌های آنها در برنامه شما) قرار گیرد.


کد زیر نتیجه استخراج کد پایگاه داده از کلاس DbAndFileManager به کلاس جداگانه خود و در فضای نام صحیح است:

```C#

using System;
using System.Data.SqlClient;
namespace CH01_CodingStandardsAndPrinciples.GoodCode.Data
{
    public class DatabaseManager
    {
        #region Database Operations
        public void OpenDatabaseConnection() { throw new
            NotImplementedException(); }
        public void CloseDatabaseConnection() { throw new
            NotImplementedException(); }
        public int ExecuteSql(string sql) { throw new
            NotImplementedException(); }
        public SqlDataReader SelectSql(string sql) { throw new
            NotImplementedException(); }
        public int UpdateSql(string sql) { throw new
            NotImplementedException(); }
        public int DeleteSql(string sql) { throw new
            NotImplementedException(); }
        public int InsertSql(string sql) { throw new
            NotImplementedException(); }
        #endregion
    }
}
```
بازسازی کد سیستم فایل منجر به کلاس FileManager در فضای نام FileSystem می‌شود، همانطور که در کد زیر نشان داده شده است:

```C#

using System;
namespace CH01_CodingStandardsAndPrinciples.GoodCode.FileSystem
{
    public class FileManager
    {
        #region File Operations
        public string ReadText(string filename) { throw new
            NotImplementedException(); }
        public void WriteText(string filename, string text) { throw new
            NotImplementedException(); }
        public byte[] ReadFile(string filename) { throw new
            NotImplementedException(); }
        [ 15 ]
        Coding Standards and Principles in C#
        Chapter 1
        public void WriteFile(string filename, byte[] binaryData) { throw
            new NotImplementedException(); }
        #endregion
    }
}
```
دیدیم که چگونه کلاس‌هایی که بیش از حد کار انجام می‌دهند را شناسایی کنیم و چگونه می‌توانیم آنها را بازسازی کنیم تا فقط یک کار را انجام دهند. اکنون بیایید این فرآیند را در مورد متدهایی که کارهای زیادی انجام می‌دهند، تکرار کنیم.

## متدهایی که کارهای زیادی انجام می‌دهند (Methods that do many things)
من خودم را بارها در متدهایی گم کرده‌ام که سطوح تورفتگی بسیار زیادی دارند و کارهای زیادی را در آن تورفتگی‌های مختلف انجام می‌دهند. ترکیبات (permutations) گیج‌کننده بودند. می‌خواستم کد را بازسازی کنم تا نگهداری آن آسان‌تر شود، اما سرپرستم این کار را ممنوع کرد. من به وضوح می‌توانستم ببینم که چگونه می‌توانست با تقسیم کردن کد به متدهای مختلف، متد کوچک‌تر شود.

وقت یک مثال است. در این مثال، متد یک رشته را می‌پذیرد. آن رشته سپس رمزگذاری (encrypted) و رمزگشایی (decrypted) می‌شود. همچنین طولانی است تا بتوانید ببینید چرا متدها باید کوچک نگه داشته شوند:

```C#

public string security(string plainText)
{
    try
    {
        byte[] encrypted;
        using (AesManaged aes = new AesManaged())
        {
            ICryptoTransform encryptor = aes.CreateEncryptor(Key, IV);
            using (MemoryStream ms = new MemoryStream())
                using (CryptoStream cs = new CryptoStream(ms, encryptor,
                    CryptoStreamMode.Write))
                {
                    using (StreamWriter sw = new StreamWriter(cs))
                        sw.Write(plainText);
                    encrypted = ms.ToArray();
                }
        }
        Console.WriteLine($"Encrypted data:
            {System.Text.Encoding.UTF8.GetString(encrypted)}");
        using (AesManaged aesm = new AesManaged())
        {
            ICryptoTransform decryptor = aesm.CreateDecryptor(Key, IV);
            using (MemoryStream ms = new MemoryStream(encrypted))
            {
                using (CryptoStream cs = new CryptoStream(ms, decryptor,
                    CryptoStreamMode.Read))
                {
                    using (StreamReader reader = new StreamReader(cs))
                        plainText = reader.ReadToEnd();
                }
            }
        }
        Console.WriteLine($"Decrypted data: {plainText}");
    }
    catch (Exception exp)
    {
        Console.WriteLine(exp.Message);
    }
    Console.ReadKey();
    return plainText;
}
```
همانطور که در متد بالا می‌بینید، ۱۰ خط کد دارد و خواندن آن دشوار است. به علاوه، بیش از یک کار را انجام می‌دهد. این کد را می‌توان به دو متد تقسیم کرد که هر یک یک وظیفه را انجام می‌دهند. یک متد یک رشته را رمزگذاری می‌کند و متد دیگر رشته را رمزگشایی می‌کند. این ما را به خوبی به این بحث می‌رساند که چرا متدها نباید بیش از ۱۰ خط کد داشته باشند.

## متدهای با بیش از ۱۰ خط کد (Methods with more than 10 lines of code)
متدهای بزرگ برای خواندن و درک کردن خوب نیستند. آن‌ها همچنین می‌توانند منجر به باگ‌هایی شوند که یافتنشان بسیار دشوار است. مشکل دیگر متدهای بزرگ این است که ممکن است هدف اصلی خود را از دست بدهند. وضعیت زمانی بدتر می‌شود که با متدهای بزرگی مواجه می‌شوید که بخش‌هایی از آن‌ها با کامنت‌ها جدا شده و کد در بخش‌ها (regions) پیچیده شده است.

اگر برای خواندن یک متد مجبور به اسکرول کردن هستید، پس بیش از حد طولانی است و می‌تواند منجر به استرس برنامه‌نویس و سوءتفسیر شود. این به نوبه خود می‌تواند به اصلاحاتی منجر شود که کد یا هدف، یا هر دو را از بین ببرد. متدها باید تا حد امکان کوچک باشند. اما باید از عقل سلیم نیز استفاده کرد، زیرا می‌توان موضوع متدهای کوچک را تا حد اغراق‌آمیز پیش برد تا جایی که بیش از حد شود. کلید دستیابی به تعادل صحیح، اطمینان از بسیار واضح بودن هدف متد و پیاده‌سازی مختصر آن است.

کد قبلی یک مثال خوب برای این است که چرا باید متدها را کوچک نگه داشت. متدهای کوچک به راحتی قابل خواندن و درک هستند. معمولاً، اگر کد شما از ۱۰ خط فراتر رود، ممکن است بیش از حد انتظار عمل کند. مطمئن شوید که متدهای شما هدف خود را نام‌گذاری می‌کنند، مانند OpenDatabaseConnection() و CloseDatabaseConnection()، و به اهداف خود پایبند باشند و از آن‌ها منحرف نشوند.

اکنون به پارامترهای متدها خواهیم پرداخت.

## متدهای با بیش از دو پارامتر (Methods with more than two parameters)
متدهای با پارامترهای زیاد تمایل دارند کمی دست و پا گیر شوند. علاوه بر دشواری در خواندن، انتقال یک مقدار به پارامتر اشتباه و شکستن ایمنی نوع (type safety) بسیار آسان است.

تست (testing) متدها با افزایش تعداد پارامترها به طور فزاینده‌ای پیچیده‌تر می‌شوند، دلیل اصلی آن این است که شما جایگشت‌های بیشتری برای اعمال در سناریوهای تست (test cases) خود دارید. ممکن است یک مورد استفاده را از دست بدهید که باعث ایجاد مشکل در فاز عملیاتی (production) خواهد شد.

## استفاده از استثناها برای کنترل جریان برنامه (Using exceptions to control program flow)
استفاده از استثناها (Exceptions) برای کنترل جریان برنامه (program flow) ممکن است هدف کد را پنهان کند. آن‌ها همچنین می‌توانند منجر به نتایج غیرمنتظره و ناخواسته شوند. این واقعیت که کد شما برای انتظار یک یا چند استثنا برنامه‌ریزی شده است، نشان‌دهنده اشتباه بودن طراحی شماست. یک سناریوی معمول که در فصل ۵، "مدیریت استثنا (Exception Handling)" با جزئیات بیشتر پوشش داده شده است.

یک سناریوی معمول زمانی است که یک کسب‌وکار از استثناهای قوانین تجاری (Business Rule Exceptions - BREs) استفاده می‌کند. یک متد عملی را با انتظار اینکه یک استثنا پرتاب شود، انجام می‌دهد. جریان برنامه توسط اینکه آیا استثنا پرتاب می‌شود یا خیر، تعیین خواهد شد. راه بسیار بهتر، استفاده از ساختارهای زبان (language constructs) موجود برای انجام اعتبارسنجی‌ها (validation checks) است که یک مقدار بولین (Boolean) را برمی‌گرداند.

کد زیر استفاده از یک BRE را برای کنترل جریان برنامه نشان می‌دهد:

```C#

public void BreFlowControlExample(BusinessRuleException bre)
{
    switch (bre.Message)
    {
        case "OutOfAcceptableRange":
            DoOutOfAcceptableRangeWork();
            break;
        default:
            DoInAcceptableRangeWork();
            break;
    }
}
```
متد BusinessRuleException را می‌پذیرد. بسته به پیام در استثنا، BreFlowControlExample() یا متد DoOutOfAcceptableRangeWork() را فراخوانی می‌کند یا متد DoInAcceptableRangeWork() را.


راه بسیار بهتر برای کنترل جریان از طریق منطق بولین (Boolean logic) است. بیایید به متد BetterFlowControlExample() زیر نگاه کنیم:

```C#

public void BetterFlowControlExample(bool isInAcceptableRange)
{
    if (isInAcceptableRange)
        DoInAcceptableRangeWork();
    else
        DoOutOfAcceptableRangeWork();
}
```
در متد BetterFlowControlExample()، یک مقدار بولین به متد پاس داده می‌شود. مقدار بولین برای تعیین مسیر اجرا استفاده می‌شود. اگر شرط در محدوده قابل قبول باشد، DoInAcceptableRangeWork() فراخوانی می‌شود. در غیر این صورت، متد DoOutOfAcceptableRangeWork() فراخوانی می‌شود.

در ادامه، کدی را که خواندن آن دشوار است، بررسی خواهیم کرد.

## کدی که خواندن آن دشوار است (Code that is difficult to read)
کدهایی مانند کد لازانیا (lasagna code) و کد اسپاگتی (spaghetti code) واقعاً برای خواندن یا دنبال کردن دشوار هستند. متدهای با نام‌گذاری بد نیز می‌توانند آزاردهنده باشند زیرا می‌توانند هدف متد را پنهان (obfuscate) کنند. متدها زمانی بیشتر پنهان می‌شوند که بزرگ باشند و متدهای مرتبط با تعدادی متد نامرتبط از هم جدا شده باشند.

کد لازانیا (Lasagna code)، که معمولاً با نام ارجاع غیرمستقیم (indirection) شناخته می‌شود، به لایه‌های انتزاع (abstraction) اشاره دارد که در آن چیزی به جای عمل، با نام ارجاع داده می‌شود. لایه‌بندی به طور گسترده در برنامه‌نویسی شی‌گرا (Object-Oriented Programming - OOP) و با اثرگذاری خوب استفاده می‌شود. با این حال، هرچه ارجاع غیرمستقیم بیشتر استفاده شود، کد می‌تواند پیچیده‌تر شود. این می‌تواند برای برنامه‌نویسان جدید در یک پروژه، درک و همگام شدن با کد را بسیار دشوار کند. بنابراین باید بین ارجاع غیرمستقیم و سهولت درک، تعادلی برقرار شود.

کد اسپاگتی (Spaghetti code) به مجموعه‌ای درهم‌تنیده از کدهای با اتصال محکم (tightly coupled) و انسجام پایین (low cohesion) اشاره دارد. نگهداری، بازسازی، توسعه و بازطراحی چنین کدهایی بسیار دشوار است. هرچند از جنبه مثبت، چون از نظر برنامه‌نویسی بیشتر روال‌گرا (procedural) است، خواندن و دنبال کردن آن می‌تواند بسیار آسان باشد. یادم می‌آید زمانی که به عنوان یک برنامه‌نویس تازه‌کار روی یک برنامه GIS با VB6 کار می‌کردم که به شرکت‌ها فروخته می‌شد و برای اهداف بازاریابی استفاده می‌شد. مدیر فنی من و برنامه‌نویسان ارشدش قبلاً سعی کرده بودند نرم‌افزار را بازطراحی کنند و شکست خورده بودند. بنابراین آن‌ها مسئولیت را به من سپردند تا برنامه را بازطراحی کنم. اما من در آن زمان در تحلیل و طراحی نرم‌افزار مهارت نداشتم، بنابراین من هم شکست خوردم.

کد بیش از حد پیچیده بود که نمی‌شد آن را دنبال کرد و به آیتم‌های مرتبط گروه‌بندی کرد، و بیش از حد بزرگ بود. با نگاه به گذشته، بهتر بود لیستی از هر کاری که برنامه انجام می‌دهد تهیه می‌کردم، لیست را بر اساس ویژگی‌ها گروه‌بندی می‌کردم و سپس لیستی از الزامات را بدون حتی نگاه کردن به کد، تهیه می‌کردم.

بنابراین درس من در بازطراحی نرم‌افزار این است که به هر قیمتی از نگاه کردن به کد خودداری کنم. همه کارهایی که برنامه انجام می‌دهد و قابلیت‌های جدیدی که باید شامل شود را یادداشت کنید. لیست را به مجموعه‌ای از الزامات نرم‌افزاری (software requirements) با وظایف، تست‌ها و معیارهای پذیرش (acceptance criteria) مرتبط تبدیل کنید، و سپس بر اساس مشخصات (specifications) برنامه‌نویسی کنید.

## کدی که اتصال محکم (Tightly Coupled) دارد
کدی که اتصال محکمی دارد، تست کردن، توسعه دادن یا اصلاح آن دشوار است. همچنین استفاده مجدد از کدی که وابسته به کدهای دیگر درون یک سیستم است، سخت می‌باشد.

یک مثال از اتصال محکم، زمانی است که به جای ارجاع به یک اینترفیس (interface)، به یک کلاس کانکریت (concrete class) در پارامتر ارجاع می‌دهید. هنگام ارجاع به یک کلاس کانکریت، هر تغییری در آن کلاس به طور مستقیم بر کلاسی که به آن ارجاع می‌دهد، تأثیر می‌گذارد. بنابراین اگر یک کلاس اتصال به پایگاه داده برای یک مشتری دارید که به SQL Server متصل می‌شود، و سپس مشتری دیگری را جذب می‌کنید که نیاز به پایگاه داده Oracle دارد، آنگاه کلاس کانکریت باید برای آن مشتری خاص و پایگاه داده اوراکل او تغییر یابد. این منجر به دو نسخه از کد خواهد شد.

هرچه تعداد مشتریان بیشتر باشد، نسخه‌های بیشتری از کد مورد نیاز است. این به زودی غیرقابل نگهداری و کابوسی واقعی برای نگهداری می‌شود. تصور کنید که کلاس اتصال به پایگاه داده شما ۱۰۰,۰۰۰ مشتری مختلف دارد که از ۱ از ۳۰ نوع مختلف کلاس استفاده می‌کنند، و همه آن‌ها یک باگ یکسان دارند که شناسایی شده و بر همه آن‌ها تأثیر می‌گذارد. این یعنی ۳۰ کلاس باید همان اصلاح را دریافت کنند، تست شوند، بسته‌بندی شده و دیپلو (deployed) شوند. این یک هزینه نگهداری بسیار زیاد و از نظر مالی بسیار گران است.

این سناریوی خاص را می‌توان با ارجاع به یک نوع اینترفیس (interface type) و سپس استفاده از یک فکتوری پایگاه داده (database factory) برای ساخت شیء اتصال مورد نیاز، برطرف کرد. سپس رشته اتصال (connection string) را می‌توان در یک فایل پیکربندی (configuration file) توسط مشتری تنظیم کرد و به فکتوری پاس داد. فکتوری سپس یک کلاس اتصال کانکریت تولید می‌کند که یک اینترفیس اتصال را برای نوع خاص پایگاه داده مشخص شده در رشته اتصال پیاده‌سازی می‌کند.

در اینجا یک مثال بد از کد با اتصال محکم آورده شده است:

```C#

public class Database
{
    private SqlServerConnection _databaseConnection;
    public Database(SqlServerConnection databaseConnection)
    
    {
        _databaseConnection = databaseConnection;
    }
}
```
همانطور که از مثال می‌بینید، کلاس پایگاه داده ما به استفاده از SQL Server وابسته است و برای پذیرش هر نوع پایگاه داده دیگری نیاز به تغییر هاردکد (hardcoded) خواهد داشت. ما در فصل‌های بعدی، بازسازی کد را با مثال‌های کد واقعی پوشش خواهیم داد.

## انسجام پایین (Low Cohesion)
انسجام پایین (Low cohesion) شامل کدهای نامرتبطی است که وظایف مختلفی را انجام می‌دهند و همگی با هم گروه‌بندی شده‌اند. یک مثال می‌تواند یک کلاس ابزار (utility class) باشد که شامل تعدادی متد ابزاری مختلف برای مدیریت تاریخ‌ها، متن، اعداد، انجام ورودی و خروجی فایل، اعتبارسنجی داده (data validation) و رمزگذاری و رمزگشایی (encryption and decryption) است.

## اشیاء سرگردان (Hanging Around) در حافظه
هنگامی که اشیاء در حافظه سرگردان می‌مانند، می‌توانند منجر به نشت حافظه (memory leaks) شوند.

متغیرهای استاتیک (Static variables) می‌توانند به چندین روش منجر به نشت حافظه شوند. اگر از DependencyObject یا INotifyPropertyChanged استفاده نمی‌کنید، در واقع در حال مشترک شدن در رویدادها (subscribing to events) هستید. Common Language Runtime (CLR) با استفاده از رویداد ValueChanged از طریق رویداد PropertyDescriptors AddValueChanged، یک ارجاع قوی (strong reference) ایجاد می‌کند که منجر به ذخیره PropertyDescriptor می‌شود که به شیء‌ای که به آن متصل است، ارجاع می‌دهد.

مگر اینکه اشتراک‌گذاری (unsubscribe) خود را لغو کنید، در نهایت با نشت حافظه مواجه خواهید شد. همچنین با استفاده از متغیرهای استاتیک که به اشیایی ارجاع می‌دهند که آزاد نمی‌شوند، با نشت حافظه مواجه خواهید شد. هر شیئی که توسط یک متغیر استاتیک ارجاع داده می‌شود، توسط جمع‌آوری‌کننده زباله (garbage collector) به عنوان "عدم جمع‌آوری" علامت‌گذاری می‌شود. این به این دلیل است که متغیرهای استاتیک که به اشیاء ارجاع می‌دهند، ریشه‌های جمع‌آوری زباله (Garbage Collection (GC) roots) هستند، و هر چیزی که یک ریشه GC باشد توسط جمع‌آوری‌کننده زباله به عنوان "عدم جمع‌آوری" علامت‌گذاری می‌شود.

هنگامی که از متدهای ناشناس (anonymous methods) استفاده می‌کنید که اعضای کلاس (class members) را گرفتن (capture) می‌کنند، نمونه کلاس ارجاع داده می‌شود. این باعث می‌شود که ارجاع به نمونه کلاس تا زمانی که متدهای ناشناس زنده هستند، زنده بماند.

هنگام استفاده از کد مدیریت‌نشده (unmanaged code - COM)، اگر اشیاء مدیریت‌شده و مدیریت‌نشده را آزاد نکنید و هر حافظه‌ای را به طور صریح آزاد (deallocate) نکنید، با نشت حافظه مواجه خواهید شد.

کدی که به طور نامحدود کش (cache) می‌کند بدون استفاده از ارجاعات ضعیف (weak references)، حذف کش استفاده‌نشده، یا محدود کردن اندازه کش، در نهایت با کمبود حافظه مواجه خواهد شد.

اگر بخواهید ارجاعاتی به شیء در یک نخ (thread) ایجاد کنید که هرگز پایان نمی‌یابد، نیز با نشت حافظه مواجه خواهید شد.

اشتراک‌های رویداد (Event subscriptions) که ناشناس نیستند، کلاس‌ها را ارجاع می‌دهند. تا زمانی که این رویدادها مشترک بمانند، اشیاء در حافظه باقی خواهند ماند. بنابراین مگر اینکه از رویدادها در زمانی که نیازی به آن‌ها نیست، لغو اشتراک کنید، احتمالاً با نشت حافظه مواجه خواهید شد.

## استفاده از متد Finalize()
در حالی که فاینالایزرها (finalizers) می‌توانند به آزادسازی منابع (resources) از اشیایی که به درستی دور انداخته نشده‌اند (disposed of) کمک کنند و از نشت حافظه جلوگیری کنند، اما دارای تعدادی معایب (drawbacks) هستند.

شما نمی‌دانید فاینالایزرها چه زمانی فراخوانی خواهند شد. آنها توسط جمع‌آوری‌کننده زباله همراه با تمام وابستگان در گراف به نسل بعدی ارتقا می‌یابند و تا زمانی که جمع‌آوری‌کننده زباله تصمیم نگیرد، جمع‌آوری نخواهند شد. این بدان معناست که اشیاء می‌توانند برای مدت طولانی در حافظه باقی بمانند. خطاهای کمبود حافظه (Out-of-memory exceptions) ممکن است با استفاده از فاینالایزرها رخ دهد، زیرا می‌توانید اشیاء را سریع‌تر از آنکه جمع‌آوری زباله شوند، ایجاد کنید.

## مهندسی بیش از حد (Over-engineering)
مهندسی بیش از حد (Over-engineering) می‌تواند یک کابوس مطلق باشد. بزرگترین دلیل آن این است که به عنوان یک انسان معمولی، پیشروی (wading through) در یک سیستم عظیم، تلاش برای درک آن، نحوه استفاده از آن و اینکه هر چیز کجا قرار می‌گیرد، یک فرآیند زمان‌بر است. به خصوص زمانی که هیچ مستنداتی وجود ندارد، شما تازه وارد سیستم هستید، و حتی افرادی که مدت‌ها طولانی‌تر از شما از آن استفاده کرده‌اند، قادر به پاسخگویی به سوالات شما نیستند.

این می‌تواند عامل اصلی استرس باشد زمانی که انتظار می‌رود با مهلت‌های تعیین شده روی آن کار کنید.

### یاد بگیرید ساده باشید، احمق! (Learn to Keep It Simple, Stupid - KISS)
یک مثال خوب از این موضوع در یکی از جاهایی است که من کار کرده‌ام. من باید یک تست برای یک برنامه وب (web app) می‌نوشتم که JSON را از یک سرویس می‌پذیرفت، به یک کودک اجازه می‌داد یک تست انجام دهد و سپس امتیاز نهایی را به سرویس دیگری منتقل می‌کرد. من از OOP، SOLID یا DRY استفاده نکردم، همانطور که طبق سیاست شرکت باید انجام می‌دادم. اما با استفاده از KISS و برنامه‌نویسی روال‌گرا (procedural programming) با رویدادها در یک بازه زمانی بسیار کوتاه، کار را انجام دادم. به دلیل آن جریمه شدم و مجبور شدم آن را با استفاده از پخش‌کننده تست (test player) خودشان بازنویسی کنم.

بنابراین شروع به یادگیری پخش‌کننده تست آن‌ها کردم. هیچ مستنداتی وجود نداشت، از اصول DRY آن‌ها پیروی نمی‌کرد، و افراد بسیار کمی اگر کسی آن را واقعاً درک می‌کرد. به جای چند روز، مانند سیستم جریمه‌شده من، نسخه جدید من که باید از سیستم آن‌ها استفاده می‌کرد، هفته‌ها طول کشید تا ساخته شود زیرا کاری را که من نیاز داشتم انجام نمی‌داد، و اجازه نداشتم آن را اصلاح کنم تا کاری را که نیاز داشتم انجام دهد. بنابراین من کند شدم در حالی که منتظر بودم کسی کاری را که لازم بود انجام دهد.

اولین راه‌حل من الزامات کسب‌وکار (business requirements) را برآورده کرد و یک قطعه کد مستقل بود که به هیچ چیز دیگری اهمیت نمی‌داد. راه‌حل دوم الزامات فنی (technical requirements) تیم توسعه را برآورده کرد. پروژه طولانی‌تر از مهلت تعیین شده ادامه یافت. هر پروژه‌ای که از مهلت خود تجاوز می‌کند (overshoots its deadline)، هزینه بیشتری نسبت به برنامه‌ریزی شده به کسب‌وکار تحمیل می‌کند.

نکته دیگری که می‌خواهم در مورد سیستم جریمه‌شده خود بگویم این بود که بسیار ساده‌تر و قابل درک‌تر از سیستم جدیدتر بود که برای استفاده از پخش‌کننده تست عمومی بازنویسی شد.

شما همیشه مجبور نیستید از OOP، SOLID و DRY پیروی کنید. گاهی اوقات عدم پیروی از آن‌ها به صرفه است. به هر حال، می‌توانید زیباترین سیستم OOP را بنویسید. اما در زیر کاپوت، کد شما به کد روال‌گرا تبدیل می‌شود که به آنچه کامپیوتر می‌فهمد نزدیک‌تر است!

## عدم وجود بخش‌ها (Regions) در کلاس‌های بزرگ
کلاس‌های بزرگ با بخش‌های زیاد، خواندن و دنبال کردنشان بسیار دشوار است، به خصوص زمانی که متدهای مرتبط با هم گروه‌بندی نشده‌اند. بخش‌ها برای گروه‌بندی اعضای مشابه درون یک کلاس بزرگ بسیار خوب هستند. اما اگر از آن‌ها استفاده نکنید، هیچ فایده‌ای ندارند!

## کد با هدف گمشده (Lost-intention code)
اگر در حال مشاهده یک کلاس هستید و چندین کار را انجام می‌دهد، چگونه می‌دانید هدف اصلی آن چه بوده است؟ برای مثال، اگر به دنبال یک متد تاریخ هستید و آن را در یک کلاس فایل در فضای نام ورودی/خروجی کد خود پیدا می‌کنید، آیا متد تاریخ در مکان صحیح قرار دارد؟ خیر. آیا برای سایر توسعه‌دهندگانی که کد شما را نمی‌شناسند، یافتن آن متد دشوار خواهد بود؟ البته که همینطور است. به این کد نگاهی بیندازید:

```C#

public class MyClass
{
    public void MyMethod()
    {
        // ...implementation...
    }
    public DateTime AddDates(DateTime date1, DateTime date2)
    [ 23 ]
    Coding Standards and Principles in C#
    Chapter 1
    {
    }
        //...implementation...
    public Product GetData(int id)
    {
        //...implementation...
    }
}
```
هدف این کلاس چیست؟ نام آن هیچ نشانی نمی‌دهد، و MyMethod چه کاری انجام می‌دهد؟ همچنین به نظر می‌رسد کلاس در حال دستکاری تاریخ و دریافت داده محصول است. متد AddDates باید در کلاسی باشد که منحصراً برای مدیریت تاریخ‌ها است. و متد GetData باید در مدل ویو (view model) محصول باشد.
