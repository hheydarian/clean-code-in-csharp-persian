# فصل ششم: تست واحد (Unit Testing) 🧪

قبلاً به بررسی **مدیریت استثناها (Exception Handling)** پرداختیم، چگونگی پیاده‌سازی صحیح آن و این که چگونه این کار می‌تواند برای **مشتری** و **برنامه‌نویس** هنگام بروز مشکلات مفید باشد. در این فصل، نگاهی می‌اندازیم به اینکه **برنامه‌نویسان چگونه می‌توانند تضمین کیفیت خود (QA)** را پیاده‌سازی کنند تا **کد باکیفیت، مقاوم و کم‌احتمال تولید استثنا در محیط تولید** ارائه دهند.

ابتدا بررسی می‌کنیم **چرا باید کد خودمان را تست کنیم** و یک تست خوب چه ویژگی‌هایی دارد. سپس به **چند ابزار تست** که برای برنامه‌نویسان C# در دسترس است می‌پردازیم. بعد، سه ستون اصلی **تست واحد (Unit Testing)** را مرور می‌کنیم: **Fail، Pass و Refactor**. در نهایت، به **تست‌های واحد اضافی (Redundant Unit Tests)** و دلیل حذف آن‌ها می‌پردازیم.

در این فصل، مباحث زیر پوشش داده می‌شوند:

* درک **دلایل داشتن یک تست خوب** ✅
* درک **ابزارهای تست** 🛠️
* تمرین **متدولوژی TDD – Fail، Pass و Refactor** 🔄
* حذف **تست‌ها، کامنت‌ها و کدهای مرده اضافی** 🗑️

تا پایان این فصل، شما مهارت‌های زیر را کسب خواهید کرد:

* توانایی **شرح مزایای داشتن کد خوب** ✨
* توانایی **شرح مشکلات احتمالی که از عدم تست واحد ایجاد می‌شود** ⚠️
* توانایی **نصب و استفاده از MSTest برای نوشتن و اجرای تست‌های واحد** 🖥️
* توانایی **نصب و استفاده از NUnit برای نوشتن و اجرای تست‌های واحد** 🖥️
* توانایی **نصب و استفاده از Moq برای نوشتن اشیاء جعلی (Mock Objects)** 🎭
* توانایی **نصب و استفاده از SpecFlow برای نوشتن نرم‌افزار مطابق با مشخصات مشتری** 📋
* توانایی **نوشتن تست‌هایی که ابتدا Fail می‌شوند، سپس Pass شوند و در نهایت هر Refactoring لازم را انجام دهید** 🔄

---

## **نیازمندی‌های فنی 🛠️**

برای دسترسی به فایل‌های کد این فصل، می‌توانید به این لینک مراجعه کنید:
[https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH06](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH06) 📂


### **درک دلایل داشتن یک تست خوب 🧩**

به‌عنوان یک برنامه‌نویس، کار روی یک پروژه توسعه جدید که برایتان جذاب است بسیار لذت‌بخش است، مخصوصاً اگر انگیزه بالایی برای انجام آن داشته باشید. اما وقتی ناگهان مجبور می‌شوید برای رفع یک **باگ (Bug)** به پروژه‌ای دیگر بروید، این موضوع می‌تواند بسیار ناامیدکننده باشد. وضعیت بدتر وقتی است که آن کد، **کد خودتان نباشد** و شما درک کامل از پشت صحنه‌ی آن نداشته باشید. و بدتر از همه وقتی است که **کد خودتان باشد** و لحظه‌ای داشته باشید که فکر کنید: «واقعاً داشتم به چه چیزی فکر می‌کردم؟!»

هر چه بیشتر از توسعه جدید کنار گذاشته شوید تا به **نگهداری کد موجود** بپردازید، بیشتر به اهمیت **تست واحد (Unit Testing)** پی می‌برید. با افزایش این درک، به مزایای واقعی **یادگیری متدولوژی‌ها و تکنیک‌های تست مانند TDD و BDD** پی خواهید برد.

---

وقتی مدتی به‌عنوان برنامه‌نویس نگهداری روی کد دیگران کار کرده باشید، با **کد خوب، بد و زشت** مواجه می‌شوید. چنین تجربه‌ای می‌تواند به شما آموزش دهد که چه کارهایی را نباید انجام دهید و چرا، و در نتیجه روش بهتری برای برنامه‌نویسی یاد بگیرید. کدهای بد ممکن است باعث شوند فریاد بزنید: «نه! واقعاً نه!» و کدهای زشت ممکن است چشمتان را بسوزاند و ذهن شما را فلج کند. 😖

---

وقتی مستقیم با مشتریان در تماس هستید و به آن‌ها **پشتیبانی فنی** می‌دهید، اهمیت تجربه‌ی خوب مشتری را در موفقیت کسب‌وکار می‌بینید. برعکس، تجربه‌ی بد مشتری می‌تواند منجر به مشتریان بسیار ناراضی، عصبانی و حتی پرخاشگر شود و فروش به‌سرعت کاهش یابد، به‌ویژه اگر مشتریان نظر منفی خود را در شبکه‌های اجتماعی و سایت‌های نقد منتشر کنند. 📉💬

---

به‌عنوان **تک‌لید (Tech Lead)**، مسئولیت شما انجام **بازبینی کد فنی (Code Review)** است تا اطمینان حاصل شود که کارکنان از **راهنمای کدنویسی و سیاست‌های شرکت** پیروی می‌کنند، باگ‌ها را بررسی و اولویت‌بندی می‌کنید و به **مدیر پروژه** در مدیریت تیم خود کمک می‌کنید. مهارت‌های لازم شامل: **مدیریت پروژه سطح بالا، جمع‌آوری و تحلیل نیازمندی‌ها، طراحی معماری، برنامه‌نویسی پاک (Clean Programming)** و داشتن مهارت‌های ارتباطی خوب است. 🤝

مدیر پروژه معمولاً تنها به **تحویل پروژه به موقع و طبق بودجه** اهمیت می‌دهد و چندان اهمیتی به نحوه‌ی کدنویسی شما نمی‌دهد؛ مهم این است که نرم‌افزار به‌موقع و مطابق با بودجه تحویل داده شود. همچنین کیفیت کد می‌تواند برند شرکت را تقویت یا تخریب کند. 🏢⚡

---

به‌عنوان تک‌لید، شما بین مدیر پروژه و تیم پروژه قرار دارید. در کار روزمره، **جلسات اسکرام (Scrum Meetings)** برگزار می‌کنید و با مشکلات روزمره برخورد می‌کنید: برنامه‌نویسان نیازمند منابع از تحلیل‌گران، تسترها منتظر رفع باگ‌ها، و غیره. سخت‌ترین کار، انجام **بازبینی کد همکاران (Peer Code Review)** و ارائه بازخورد سازنده است که نتیجه مطلوب بدهد بدون اینکه کسی آزرده شود. به همین دلیل **تست واحد و کدنویسی پاک** باید جدی گرفته شود. ⚖️

---

به همین دلیل، به‌عنوان تک‌لید، تشویق به **TDD** بسیار مهم است و بهترین راه **الگوبرداری از خودتان** است. حتی برنامه‌نویسان با تجربه ممکن است نسبت به TDD مقاومت داشته باشند، زیرا یادگیری و پیاده‌سازی آن **زمان‌بر** به نظر می‌رسد، مخصوصاً در کدهای پیچیده‌تر. اما اگر می‌خواهید واقعاً مطمئن باشید که پس از نوشتن کد، کیفیت آن تضمین شده و باگ به شما بازنمی‌گردد، **TDD یک روش عالی برای ارتقای مهارت‌های شماست**. 💡

---

همچنین، میزان اهمیت تست واحد به **حساسیت نرم‌افزار** بستگی دارد. باگ در یک اپلیکیشن ساده یادداشت‌برداری فاجعه‌آمیز نیست، اما در **صنعت دفاع یا سلامت** ممکن است عواقب مرگباری داشته باشد. مثال‌ها: موشک هدایت‌شده به سوی غیرنظامیان، تجهیزات پزشکی که به دلیل باگ باعث مرگ بیمار می‌شود یا نرم‌افزار ایمنی هواپیما که باعث سقوط می‌شود. ✈️💥

هر چه نرم‌افزار حساس‌تر باشد، **تکنیک‌های تست واحد مانند TDD و BDD** اهمیت بیشتری پیدا می‌کنند. هنگام نوشتن نرم‌افزار، تصور کنید اگر شما مشتری بودید و کد خراب شد، چه پیامدی داشت؟ چگونه بر خانواده، دوستان و همکاران تأثیر می‌گذاشت؟ همچنین پیامدهای **اخلاقی و قانونی** را در نظر بگیرید. ⚖️👨‍👩‍👧‍👦

---

با اینکه گفته می‌شود: "برنامه‌نویس نباید کد خود را تست کند"، این تنها زمانی صحیح است که **کد تمام شده و آماده تست قبل از تولید** باشد. در طول برنامه‌نویسی، برنامه‌نویسان همیشه باید **کد خود را تست کنند**.

تست واحد به شما کمک می‌کند **عادات برنامه‌نویسی پاک** ایجاد کنید: ابتدا تست می‌نویسید، سپس کد کافی برای موفقیت تست اضافه می‌کنید و بعد کد را بازسازی (Refactor) می‌کنید. این چرخه باعث می‌شود کد شما **خواناتر، قابل نگهداری و قابل اعتماد** باشد. 🔄

---

در حین نوشتن کد، تست‌ها باید **Atomic یا تک وظیفه‌ای** باشند؛ یعنی هر تست فقط یک ویژگی را بررسی کند. تست باید **تکرارپذیر، قابل اطمینان و سریع (میلی‌ثانیه‌ای)** باشد. کدهای تست طولانی یا وابسته به دیگر تست‌ها مناسب نیستند. اگر نیاز به یک ثانیه یا بیشتر دارند، باید **Refactor یا استفاده از Mock Objects** در نظر گرفته شود. ⏱️🧪

---

چرخه‌ی تست واحد شامل مراحل زیر است:

1. نوشتن **کلاس تست و شبه‌کد (Pseudocode)**
2. نوشتن **متدهای تست که ابتدا Fail می‌شوند**
3. نوشتن کد کافی برای **Pass شدن تست**
4. **Refactor کد** و ادامه به تست بعدی

---

در ادامه، فصل به بررسی **Use Case، Test Design، Test Case و Test Suite** و نحوه تعامل آن‌ها با یکدیگر می‌پردازد:

* **Use Case:** جریان عملیاتی یک عملیات واحد، مانند افزودن رکورد مشتری.
* **Test Design:** شامل یک یا چند **Test Case** برای سناریوهای مختلف Use Case.
* **Test Case:** می‌تواند دستی یا خودکار باشد.
* **Test Suite:** نرم‌افزاری برای کشف، اجرای تست‌ها و گزارش نتایج به کاربر نهایی.

توسعه‌دهندگان باید روی نوشتن و استفاده از **تست واحد خود** تمرکز کنند تا کدهایی که **Fail، Pass و Refactor** می‌شوند، تولید کنند. 🖥️✅

