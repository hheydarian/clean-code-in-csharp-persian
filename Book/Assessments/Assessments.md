# ارزیابی‌ها

ارزیابی‌ها 📊

**فصل ۱**

1.
2.
3.
4.
5.
6.
7.
8.

* یکی از نتایج کد ضعیف این است که ممکن است در نهایت با قطعه‌ای از کد بسیار بد و سخت برای درک مواجه شوید. این موضوع اغلب به استرس برنامه‌نویس و نرم‌افزاری منجر می‌شود که باگ دارد، نگهداری آن دشوار است و تست و توسعه آن سخت است.
* یکی از نتایج کد خوب این است که خواندن و درک آن آسان است، زیرا قصد برنامه‌نویس مشخص است. این باعث کاهش استرس برای برنامه‌نویسانی می‌شود که باید کد را دیباگ، تست و توسعه دهند.
* وقتی یک پروژه بزرگ را به کامپوننت‌ها و کتابخانه‌های ماژولار تقسیم می‌کنید، هر ماژول می‌تواند به‌طور هم‌زمان توسط تیم‌های جداگانه کار شود. ماژول‌های کوچک آسان‌تر تست، کدنویسی، مستندسازی، انتشار، توسعه و نگهداری می‌شوند.
* **DRY** مخفف **Don’t Repeat Yourself** است. به دنبال کدهای تکراری باشید و با بازسازی (Refactor) آن‌ها، کدهای تکراری را حذف کنید. مزیت این کار برنامه‌های کوچکتر است، زیرا اگر چنین کدی دارای باگ باشد، تنها کافی است آن را در یک مکان اصلاح کنید.
* **KISS** به معنای نوشتن کدی ساده است که برنامه‌نویسان، به‌ویژه افراد تازه‌کار، را گیج نکند. کد KISS آسان برای خواندن و نوشتن تست است.
* **S** اصل **Single Responsibility Principle**، **O** اصل **Open/Closed Principle**، **L** اصل **Liskov Substitution**، **I** اصل **Interface Segregation Principle** و **D** اصل **Dependency Inversion Principle** است.
* **YAGNI** مخفف **You Aren’t Going to Need It** است. به عبارت دیگر، کدی اضافه نکنید که به آن نیاز ندارید. فقط کدی را اضافه کنید که واقعاً لازم است و بس.
* **Occam’s Razor** اصل می‌گوید: «موجودیت‌ها نباید بدون ضرورت چند برابر شوند.» فقط با واقعیت‌ها سر و کار داشته باشید و تنها در صورت لزوم فرضیات بسازید.

---

**فصل ۲**

1.
2.

* دو نقش در بازبینی همتای کد (**Peer Code Review**) وجود دارد: **Reviewer** و **Reviewee**.
* مدیر پروژه افراد شرکت‌کننده در بازبینی همتا را مشخص می‌کند.

3.
4.
5.

* شما می‌توانید زمان و تلاش **Reviewer** را قبل از درخواست بازبینی همتا ذخیره کنید، با اطمینان از اینکه کد و تست‌های شما به‌درستی کار می‌کنند، تحلیل کد (Code Analysis) روی پروژه انجام داده و مشکلات را رفع کرده و اطمینان حاصل کنید که کد شما از دستورالعمل‌های کدنویسی شرکت پیروی می‌کند.
* هنگام بررسی کد، به نام‌گذاری، قالب‌بندی، سبک‌های برنامه‌نویسی، باگ‌های احتمالی، صحت کد و تست‌ها، امنیت و مسائل مربوط به عملکرد توجه کنید.
* سه دسته بازخورد شامل مثبت، اختیاری و بحرانی است.

---

**فصل ۳**

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.

* می‌توانیم کد خود را در فایل‌های منبع جداگانه و در ساختار پوشه‌ای قرار دهیم و کلاس‌ها، اینترفیس‌ها، Structها و Enumها را در Namespaceهایی که به ساختار پوشه‌ها نگاشت دارند، قرار دهیم.
* یک کلاس باید فقط یک مسئولیت داشته باشد.
* می‌توانید برای تولید مستندات از نظرات XML استفاده کنید که مستقیماً بالای عضو Public که باید مستندسازی شود قرار می‌گیرد.
* **Cohesion** به گروه‌بندی منطقی کدی گفته می‌شود که روی همان مسئولیت کار می‌کند.
* **Coupling** به وابستگی بین کلاس‌ها اشاره دارد.
* **Cohesion** باید بالا باشد.
* **Coupling** باید پایین باشد.
* می‌توانید از **DI** و **IoC** برای طراحی قابل تغییر استفاده کنید.
* **DI** مخفف **Dependency Injection** است.
* **IoC** مخفف **Inversion of Control** است.
* اشیاء **Immutable** ایمن از نظر نوع هستند و بنابراین می‌توان آن‌ها را بین Threads به‌طور ایمن منتقل کرد.
* اشیاء باید متدها و Properties را آشکار کنند و داده‌ها را پنهان کنند.
* ساختارهای داده‌ای (Data Structures) باید داده‌ها را آشکار کنند و متدی نداشته باشند.

---

**فصل ۴**

1.
2.
3.
4.

* متدهایی بدون پارامتر **Niladic Methods** نامیده می‌شوند.
* متدهایی با یک پارامتر **Monadic Methods** نامیده می‌شوند.
* متدهایی با دو پارامتر **Dyadic Methods** نامیده می‌شوند.
* متدهایی با سه پارامتر **Triadic Methods** نامیده می‌شوند.

5.
6.
7.
8.
9.
10.
11.
12.
13.
14.

* متدهایی با بیش از سه پارامتر **Polyadic Methods** نامیده می‌شوند.
* باید از کد تکراری اجتناب کنید. این روش برنامه‌نویسی مولد نیست، می‌تواند برنامه‌ها را بی‌دلیل بزرگ کند و احتمال دارد که همان Exception در کل کد تکرار شود.
* برنامه‌نویسی تابعی (**Functional Programming**) روشی در کدنویسی است که محاسبات را به‌عنوان ارزیابی ریاضی محاسبات در نظر می‌گیرد و وضعیت (**State**) را تغییر نمی‌دهد.
* مزایای برنامه‌نویسی تابعی شامل کد ایمن در برنامه‌های چندنخی (**Multithreaded**) و متدهای کوچک‌تر و معنادار است که خواندن و درک آن‌ها آسان است.
* ورودی و خروجی می‌تواند برای برنامه‌های تابعی مشکل‌ساز باشد، زیرا برنامه‌نویسی تابعی اجازه اثرات جانبی (**Side-effects**) نمی‌دهد.
* کد **WET** برخلاف DRY است و هر بار که نیاز است نوشته می‌شود. این باعث تکرار می‌شود و همان Exception می‌تواند در چندین مکان رخ دهد و نگهداری و پشتیبانی را دشوار کند.
* کد **DRY** برخلاف WET است و تنها یک بار نوشته می‌شود و هر جا نیاز است استفاده می‌شود. این باعث کاهش حجم کد و تعداد Exceptionها می‌شود و برنامه‌ها را آسان‌تر برای خواندن و نگهداری می‌کند.
* شما با بازسازی (**Refactoring**) کد WET و حذف کد تکراری، آن را به کد DRY تبدیل می‌کنید.
* متدهای طولانی سنگین و مستعد Exception هستند. هر چه کوچک‌تر باشند، خواندن و نگهداری آن‌ها آسان‌تر است و احتمال ایجاد باگ‌های منطقی توسط برنامه‌نویس کمتر می‌شود.
* برای اجتناب از استفاده از **Try/Catch**، می‌توانید **Argument Validators** بنویسید و آن‌ها را در بالای متد خود فراخوانی کنید. اگر پارامترها در اعتبارسنجی شکست بخورند، Exception مناسب ایجاد شده و متد اجرا نمی‌شود.

---

**فصل ۵**

1.
2.
3.
4.

* **Checked Exception**، Exceptionی است که در زمان Compile بررسی می‌شود.
* **Unchecked Exception**، Exceptionی است که بررسی نمی‌شود یا به‌سادگی نادیده گرفته می‌شود.
* **Overflow Exception** زمانی رخ می‌دهد که بیت‌های سطح بالا نتوانند به نوع مقصد اختصاص یابند. در حالت Checked، **OverflowException** رخ می‌دهد. در حالت Unchecked، بیت‌های سطح بالا که نمی‌توانند اختصاص یابند نادیده گرفته می‌شوند.
* تلاش برای دسترسی به Property یا Method روی یک Object **Null**.

5.
6.
7.
8.
9.
10.

* یک کلاس **Validator** و یک کلاس **Attribute** پیاده‌سازی کنید که پارامتر را برای **Null** بررسی کند و **ArgumentNullException** پرتاب کند. از کلاس Validator در بالای متدهای خود استفاده کنید تا قبل از اجرای متد، Exception رخ دهد.
* **Business Rule Exception (BRE)**
* BREها روش بدی هستند، زیرا انتظار دارند Exception ایجاد شود تا جریان برنامه کنترل شود.
* برنامه‌نویسی صحیح نباید جریان برنامه را با انتظار Exception به‌عنوان خروجی کنترل کند. بنابراین با توجه به اینکه BREها روش نادرستی هستند، راه بهتر استفاده از برنامه‌نویسی شرطی (**Conditional Programming**) است. در برنامه شرطی، از منطق بولی (**Boolean Logic**) استفاده می‌کنید.
* منطق بولی دو مسیر ممکن برای اجرا فراهم می‌کند و هیچ Exceptionی پرتاب نمی‌کند. بررسی‌های شرطی واضح هستند و خواندن و نگهداری برنامه را آسان می‌کنند و به راحتی قابل گسترش هستند، در حالی که با BREها این امکان وجود ندارد.
* ابتدا با گرفتن خطا برای انواع شناخته شده Exception مانند **ArgumentNullException** و **OverflowException** با استفاده از انواع Exception موجود در **Microsoft .NET Framework** شروع کنید. اما وقتی این‌ها کافی نباشند و داده کافی برای موقعیت شما فراهم نکنند، Exceptionهای سفارشی خود را بنویسید و از آن‌ها استفاده کنید و پیام‌های Meaningful ارائه دهید.
* Exception سفارشی شما باید از **System.Exception** ارث‌بری کند و سه سازنده (**Constructor**) داشته باشد: سازنده پیش‌فرض، سازنده‌ای که پیام متنی را می‌پذیرد، و سازنده‌ای که پیام متنی و Inner Exception را می‌پذیرد.

---

اگر مایل باشید، می‌توانم ادامه فصل‌ها (۶ تا ۱۴) را هم به همین سبک ترجمه کنم تا مجموعه کامل ارزیابی‌ها به فارسی آماده شود. آیا ادامه دهم؟
