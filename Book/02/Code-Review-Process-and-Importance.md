# 2
# بازبینی کد – فرآیند و اهمیت (Code Review – Process and Importance)
انگیزه اصلی پشت هر بازبینی کد (code review)، بهبود کیفیت کلی کد است. کیفیت کد (Code quality) بسیار مهم است. این تقریباً ناگفته پیداست، به خصوص اگر کد شما بخشی از یک پروژه تیمی باشد یا برای دیگران، مانند توسعه‌دهندگان متن‌باز (open source developers) و مشتریان از طریق توافق‌نامه‌های امانی (escrow agreements)، قابل دسترسی باشد.

اگر هر توسعه‌دهنده‌ای آزاد بود تا هر طور که می‌خواهد کدنویسی کند، در نهایت با یک نوع کد مواجه می‌شدید که به روش‌های بسیار متفاوتی نوشته شده بود، و نهایتاً کد به یک آشفته‌بازار غیرقابل کنترل (unwieldy mess) تبدیل می‌شد. به همین دلیل مهم است که یک سیاست استانداردهای کدنویسی (coding standards policy) داشته باشیم که شیوه‌های کدنویسی شرکت و رویه بازبینی کد (code review procedures) را که باید رعایت شوند، تشریح کند.

هنگامی که بازبینی کد انجام می‌شود، همکاران کد یکدیگر را بازبینی خواهند کرد. همکاران درک خواهند کرد که اشتباه کردن فقط یک ویژگی انسانی است. آن‌ها کد را برای یافتن اشتباهات، کدنویسی‌ای که قوانین رفتار کدنویسی شرکت (company's code of coding conduct) را نقض می‌کند، و هر کدی که، در حالی که از نظر نحوی صحیح (syntactically correct) است، می‌تواند بهبود یابد تا یا خواناتر (more readable)، یا قابل نگهداری‌تر (more maintainable)، یا کارآمدتر (more performant) شود، بررسی خواهند کرد.


بنابراین، در این فصل، موضوعات زیر را برای درک جزئیات فرآیند بازبینی کد پوشش خواهیم داد:

+ آماده‌سازی کد برای بازبینی

+ رهبری یک بازبینی کد

+ دانستن اینکه چه چیزی را بازبینی کنیم

+ دانستن اینکه چه زمانی کد را برای بازبینی بفرستیم

+ ارائه و پاسخ به بازخورد بازبینی

لطفاً توجه داشته باشید که برای بخش‌های آماده‌سازی کد برای بازبینی و دانستن اینکه چه زمانی کد را برای بازبینی بفرستیم، از دیدگاه برنامه‌نویس (programmer) صحبت خواهیم کرد. برای بخش‌های رهبری یک بازبینی کد و دانستن اینکه چه چیزی را بازبینی کنیم، از دیدگاه بازبینی‌کننده کد (code reviewer) صحبت خواهیم کرد. با این حال، در مورد بخش ارائه و پاسخ به بازخورد بازبینی، دیدگاه‌های هر دو برنامه‌نویس و بازبینی‌کننده کد را پوشش خواهیم داد.

اهداف یادگیری این فصل این است که شما بتوانید کارهای زیر را انجام دهید:

+ بازبینی‌های کد و چرایی مفید بودن آن‌ها را درک کنید.

+ در بازبینی‌های کد شرکت کنید.

+ انتقاد سازنده (constructive criticism) ارائه دهید.

+ به انتقاد سازنده به طور مثبت پاسخ دهید.

قبل از اینکه عمیقاً به این موضوعات بپردازیم، بیایید فرآیند کلی بازبینی کد را درک کنیم.

## فرآیند بازبینی کد (The code review process)
رویه عادی برای انجام یک بازبینی کد این است که مطمئن شوید کد شما کامپایل (compiles) می‌شود و الزامات تعیین شده را برآورده می‌کند. همچنین باید تمام تست‌های واحد (unit tests) و تست‌های سرتاسری (end-to-end tests) را پاس کند. هنگامی که مطمئن شدید که می‌توانید کد خود را با موفقیت کامپایل، تست و اجرا کنید، سپس آن را در شاخه کاری فعلی (current working branch) چک‌این (checked in) می‌کنید. پس از چک‌این، شما یک درخواست کشیدن (pull request) صادر خواهید کرد.

یک بازبینی‌کننده همتا (peer reviewer) سپس کد شما را بازبینی کرده و نظرات و بازخوردها را به اشتراک خواهد گذاشت. اگر کد شما از بازبینی کد عبور کند، بازبینی کد شما تکمیل شده و سپس می‌توانید شاخه کاری خود را در شاخه اصلی (main trunk) ادغام (merge) کنید. در غیر این صورت، بازبینی همتا رد خواهد شد، و از شما خواسته می‌شود که کار خود را بازبینی کرده و مسائلی را که در نظرات ارائه شده توسط بازبینی‌کننده شما مطرح شده‌اند، برطرف کنید.


دیاگرام زیر فرآیند بازبینی کد همتا را نشان می‌دهد:
<div align="center">
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-1.png) 
  
</div>

## آماده‌سازی کد برای بازبینی (Preparing code for review)
گاهی اوقات آماده‌سازی برای بازبینی کد (code review) می‌تواند یک دردسر واقعی باشد، اما قطعاً به بهبود کیفیت کلی کدی که خواندن و نگهداری آن آسان است، کمک می‌کند. این قطعاً یک روش ارزشمند است که تیم‌های توسعه‌دهنده باید آن را به عنوان رویه‌های استاندارد کدنویسی انجام دهند. این یک گام مهم در فرآیند بازبینی کد است، زیرا تکمیل این مرحله می‌تواند زمان و انرژی قابل توجهی را برای بازبینی‌کننده در انجام بازبینی صرفه‌جویی کند.

در اینجا چند نکته استاندارد وجود دارد که هنگام آماده‌سازی کد خود برای بازبینی باید در نظر داشته باشید:

+ همیشه بازبینی کد را در ذهن داشته باشید: هنگام شروع هر برنامه‌نویسی، باید بازبینی کد را در ذهن داشته باشید. بنابراین کد خود را کوچک نگه دارید. در صورت امکان، کد خود را به یک ویژگی محدود کنید.

+ اطمینان حاصل کنید که تمام تست‌های شما پاس می‌شوند حتی اگر کد شما بیلد شود: اگر کد شما بیلد (build) می‌شود اما تست‌های شکست‌خورده (failing tests) دارید، فوراً با چیزی که باعث شکست آن تست‌ها می‌شود، مقابله کنید. سپس، هنگامی که تست‌ها مطابق انتظار پاس می‌شوند، می‌توانید ادامه دهید. مهم است که اطمینان حاصل کنید که تمام تست‌های واحد (unit tests) پاس شده‌اند، و تست سرتاسری (end-to-end testing) تمام تست‌ها را پاس می‌کند. مهم است که تمام تست‌ها کامل شوند و چراغ سبز (green light) را دریافت کنند، زیرا انتشار کدی که کار می‌کند اما در تست شکست خورده بود، می‌تواند منجر به نارضایتی شدید مشتریان هنگام رفتن کد به تولید (production) شود.

+ YAGNI را به یاد داشته باشید: هنگام کدنویسی، مطمئن شوید که فقط کدی را اضافه می‌کنید که برای برآورده کردن الزام (requirement) یا ویژگی (feature) مورد نظر ضروری است. اگر هنوز به آن نیاز ندارید، آن را کدنویسی نکنید. فقط زمانی کد را اضافه کنید که به آن نیاز باشد و نه قبل از آن.

+ کد تکراری را بررسی کنید: اگر کد شما باید شی‌گرا (object-oriented) باشد و DRY و SOLID باشد، کد خود را بازبینی کنید تا ببینید آیا حاوی هیچ کد رویه‌ای (procedural) یا تکراری (duplicate code) است. اگر چنین است، وقت بگذارید و آن را بازسازی (refactor) کنید تا شی‌گرا، DRY و SOLID باشد.

+ از تحلیل‌گرهای استاتیک استفاده کنید: تحلیل‌گرهای کد استاتیک (Static code analyzers) که برای اعمال بهترین شیوه‌های شرکت (company's best practices) پیکربندی شده‌اند، کد شما را بررسی کرده و هر مشکلی را که با آن مواجه می‌شوند، برجسته می‌کنند. اطمینان حاصل کنید که اطلاعات و هشدارها را نادیده نمی‌گیرید. این‌ها می‌توانند در آینده برای شما مشکل ایجاد کنند.

مهم‌تر از همه، کد خود را فقط زمانی چک‌این (check in) کنید که مطمئن هستید کد شما الزامات تجاری (business requirements) را برآورده می‌کند، به استانداردهای کدنویسی (coding standards) پایبند است و تمام تست‌ها را پاس می‌کند. اگر کد خود را به عنوان بخشی از پایپ‌لاین یکپارچه‌سازی مداوم (Continuous Integration - CI pipeline) چک‌این کنید و کد شما بیلد (build) را شکست دهد، باید حوزه‌های نگرانی مطرح شده توسط پایپ‌لاین CI را برطرف کنید. هنگامی که می‌توانید کد خود را چک‌این کنید و CI چراغ سبز را نشان می‌دهد، می‌توانید یک درخواست کشیدن (pull request) صادر کنید.

## رهبری یک بازبینی کد (Leading a code review)
هنگام رهبری بازبینی کد، مهم است که افراد مناسب حضور داشته باشند. افرادی که در بازبینی کد همتا (peer code review) حضور خواهند داشت با مدیر پروژه (project manager) توافق خواهند شد. برنامه‌نویس(ان) مسئول ارسال کد برای بازبینی، در بازبینی کد حضور خواهند داشت مگر اینکه به صورت ریموت (remotely) کار کنند. در مورد کار ریموت، بازبینی‌کننده کد را بازبینی می‌کند و یا درخواست کشیدن (pull request) را می‌پذیرد، یا آن را رد می‌کند، یا سوالاتی را برای توسعه‌دهنده ارسال می‌کند که باید قبل از هر اقدام دیگری پاسخ داده شوند.

یک رهبر مناسب برای بازبینی کد باید مهارت‌ها و دانش زیر را داشته باشد:

+ یک مرجع فنی باشد: فردی که بازبینی کد را رهبری می‌کند باید یک مرجع فنی (technical authority) باشد که دستورالعمل‌های کدنویسی شرکت (company's coding guidelines) و متدولوژی‌های توسعه نرم‌افزار (software development methodologies) را درک کند. همچنین مهم است که آن‌ها درک کلی خوبی از نرم‌افزار تحت بازبینی داشته باشند.

+ مهارت‌های نرم خوبی داشته باشد: به عنوان رهبر بازبینی کد، فرد باید یک شخص خونگرم و تشویق‌کننده باشد که بتواند بازخورد سازنده (constructive feedback) ارائه دهد. مهم است که فردی که کد برنامه‌نویس را بازبینی می‌کند مهارت‌های نرم (soft skills) خوبی داشته باشد تا هیچ تضادی (conflict) بین بازبینی‌کننده و شخصی که کدش بازبینی می‌شود، وجود نداشته باشد.

+ بیش از حد انتقادی نباشد: رهبر بازبینی کد نباید بیش از حد انتقادی (over-critical) باشد و باید بتواند انتقاد (critique) خود را از کد برنامه‌نویس توضیح دهد. مفید است اگر رهبر با سبک‌های برنامه‌نویسی مختلف (different programming styles) آشنا بوده باشد و بتواند کد را عینی (objectively) بررسی کند تا اطمینان حاصل کند که الزامات پروژه را برآورده می‌کند.

در تجربه من، بازبینی‌های کد همتا همیشه بر روی درخواست‌های کشیدن (pull requests) در ابزار کنترل نسخه (version control tool) مورد استفاده تیم انجام می‌شود. یک برنامه‌نویس کد را به کنترل نسخه (version control) ارسال می‌کند و سپس یک درخواست کشیدن صادر می‌کند. سپس بازبینی‌کننده کد همتا، کد را در درخواست کشیدن بازبینی می‌کند. بازخورد سازنده (Constructive feedback) در قالب نظراتی (comments) ارائه می‌شود که به درخواست کشیدن پیوست خواهند شد. اگر مشکلی در درخواست کشیدن وجود داشته باشد، بازبینی‌کننده درخواست تغییر (change request) را رد کرده و در مورد مسائل خاصی که باید توسط برنامه‌نویس برطرف شوند، نظر می‌دهد. اگر بازبینی کد موفقیت‌آمیز باشد، بازبینی‌کننده ممکن است نظری حاوی بازخورد مثبت (positive feedback) اضافه کند، درخواست کشیدن را ادغام (merge) کند و آن را ببندد.

برنامه‌نویسان باید هر نظر داده شده توسط بازبینی‌کننده را یادداشت کرده و آن‌ها را در نظر بگیرند. اگر کد نیاز به ارسال مجدد دارد، برنامه‌نویس باید اطمینان حاصل کند که تمام نظرات بازبینی‌کننده قبل از ارسال مجدد برطرف شده‌اند.

ایده خوبی است که بازبینی‌های کد کوتاه باشند و در هر زمان بیش از حد خط کد را بازبینی نکنید.

از آنجا که بازبینی کد معمولاً با یک درخواست کشیدن شروع می‌شود، ما به صدور یک درخواست کشیدن و سپس پاسخ به یک درخواست کشیدن خواهیم پرداخت.

## صدور درخواست کشیدن (Issuing a pull request)
هنگامی که کدنویسی را تمام کرده‌اید و از کیفیت کد خود و اینکه بیلد (builds) می‌شود اطمینان دارید، می‌توانید تغییرات خود را پوش (push) یا چک‌این (check in) کنید، بسته به اینکه از چه سیستم کنترل منبع (source control system) استفاده می‌کنید. هنگامی که کد شما پوش شده است، می‌توانید یک درخواست کشیدن (pull request) صادر کنید. هنگامی که یک درخواست کشیدن مطرح می‌شود، افراد دیگری که به کد علاقه‌مند هستند مطلع می‌شوند و می‌توانند تغییرات شما را بازبینی کنند. این تغییرات سپس می‌توانند مورد بحث قرار گیرند و نظراتی در مورد هر تغییر بالقوه‌ای که باید ایجاد کنید، ارائه شود. در اصل، پوش کردن شما به مخزن کنترل منبع (source control repository) و صدور یک درخواست کشیدن است که فرآیند بازبینی کد همتا (peer code review process) را آغاز می‌کند.

برای صدور یک درخواست کشیدن، تنها کاری که باید انجام دهید (پس از اینکه کد خود را چک‌این یا پوش کردید) این است که روی تب درخواست‌های کشیدن (Pull requests) در کنترل نسخه (version control) خود کلیک کنید. سپس دکمه‌ای وجود خواهد داشت که می‌توانید روی آن کلیک کنید – درخواست کشیدن جدید (New pull request). این کار درخواست کشیدن شما را به یک صف (queue) اضافه می‌کند تا توسط بازبینی‌کنندگان مربوطه برداشته شود.

در اسکرین‌شات‌های زیر، فرآیند درخواست و تکمیل یک درخواست کشیدن از طریق گیت‌هاب (GitHub) را خواهیم دید:
1. در صفحه پروژه گیت‌هاب خود، روی تب درخواست‌های کشیدن (Pull requests) کلیک کنید:

<div align="center">
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-2.png) 
  
</div>

2. سپس، روی دکمه درخواست کشیدن جدید (New pull request) کلیک کنید. این کار صفحه مقایسه تغییرات (Comparing changes) را نمایش خواهد داد:

<div align="center">
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-3.png) 
  
</div>

3. اگر راضی هستید، سپس روی دکمه ایجاد درخواست کشیدن (Create pull request) کلیک کنید تا درخواست کشیدن را آغاز کنید. سپس صفحه باز کردن یک درخواست کشیدن (Open a pull request) به شما نمایش داده خواهد شد:

<div align="center">
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-4.png) 
</div>

4. درخواست کشیدن. تمام اطلاعات لازم را برای بازبینی‌کننده کد (code reviewer) فراهم کنید، اما آن را کوتاه و مفید نگه دارید. نظرات مفید (Useful comments) شامل شناسایی تغییرات ایجاد شده (what changes have been made) است. فیلدهای بازبینی‌کنندگان (Reviewers)، مسئولین (Assignees)، برچسب‌ها (Labels)، پروژه‌ها (Projects) و نقاط عطف (Milestones) را در صورت لزوم تغییر دهید. سپس، هنگامی که از جزئیات درخواست کشیدن راضی هستید، روی دکمه ایجاد درخواست کشیدن (Create pull request) کلیک کنید تا درخواست کشیدن ایجاد شود. کد شما اکنون آماده است تا توسط همتایان (peers) شما بازبینی شود.

## پاسخ به درخواست کشیدن (Responding to a pull request)
از آنجا که بازبینی‌کننده (reviewer) مسئول بازبینی درخواست‌های کشیدن (pull requests) قبل از ادغام شاخه‌ها (merges of branches) است، خوب است که به پاسخ به درخواست‌های کشیدن بپردازیم:

 با کلون کردن (cloning) یک کپی از کد در حال بازبینی شروع کنید.

 نظرات (comments) و تغییرات (changes) را در درخواست کشیدن بازبینی کنید.

 بررسی کنید که هیچ تضادی (conflicts) با شاخه پایه (base branch) وجود نداشته باشد. اگر وجود دارد، باید درخواست کشیدن را با نظرات لازم رد (reject) کنید. در غیر این صورت، می‌توانید تغییرات را بازبینی کنید، مطمئن شوید که کد بدون خطا بیلد (builds) می‌شود، و مطمئن شوید که هیچ هشداری در زمان کامپایل (compilation warnings) وجود ندارد. در این مرحله، همچنین به دنبال بوی کد (code smells) و هر گونه باگ احتمالی (potential bugs) خواهید بود. همچنین بررسی خواهید کرد که تست‌ها بیلد می‌شوند، اجرا می‌شوند، صحیح هستند و پوشش تست (test coverage) خوبی از ویژگی‌ای که قرار است ادغام شود، ارائه می‌دهند. هرگونه نظر لازم را اضافه کنید و درخواست کشیدن را رد کنید مگر اینکه راضی باشید. هنگامی که راضی شدید، می‌توانید نظرات خود را اضافه کرده و با کلیک بر روی دکمه ادغام درخواست کشیدن (Merge pull request)، همانطور که در اینجا نشان داده شده است، درخواست کشیدن را ادغام کنید:
<div align="center">  
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-5.png) 
</div>

4. اکنون، ادغام (merge) را با وارد کردن یک نظر (comment) و کلیک بر روی دکمه تایید ادغام (Confirm merge)، تأیید کنید:

<div align="center">  
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-6.png) 
</div>

5. ادغام (merged) شده و درخواست کشیدن (pull request) بسته شد، شاخه (branch) را می‌توان با کلیک بر روی دکمه حذف شاخه (Delete branch)، همانطور که در تصویر زیر دیده می‌شود، حذف کرد:
   
<div align="center">  
   
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-7.png) 
</div>

در بخش قبلی، دیدید که چگونه بازبینی‌شونده (reviewee) یک درخواست کشیدن (pull request) را برای بازبینی همتا (peer-reviewed) کد خود قبل از ادغام (merged) آن، مطرح می‌کند. و در این بخش، دیدید که چگونه یک درخواست کشیدن را بازبینی کرده و آن را به عنوان بخشی از بازبینی کد (code review) تکمیل کنید. اکنون، به این خواهیم پرداخت که هنگام پاسخ به یک درخواست کشیدن، چه چیزی را در بازبینی کد همتا (what to review in a peer code review) بازبینی کنیم.
## تأثیر بازخورد بر بازبینی‌شوندگان (Effects of feedback on reviewees)
هنگام انجام یک بازبینی کد (code review) از کد همکار خود، باید این واقعیت را نیز در نظر بگیرید که بازخورد (feedback) می‌تواند مثبت (positive) یا منفی (negative) باشد. بازخورد منفی (Negative feedback) جزئیات خاصی در مورد مشکل ارائه نمی‌دهد. بازبینی‌کننده (reviewer) روی بازبینی‌شونده (reviewee) و نه روی مشکل تمرکز می‌کند. پیشنهاداتی برای بهبود کد توسط بازبینی‌کننده به بازبینی‌شونده ارائه نمی‌شود و بازخورد بازبینی‌کننده با هدف آسیب رساندن (hurting) به بازبینی‌شونده است.

چنین بازخورد منفی که توسط بازبینی‌شونده دریافت می‌شود، آن‌ها را آزرده (offends) می‌کند. این امر تأثیر منفی دارد و می‌تواند باعث شود که آن‌ها به خودشان شک کنند (start doubting themselves). سپس فقدان انگیزه (lack of motivation) در بازبینی‌شونده ایجاد می‌شود و این می‌تواند به طور منفی بر تیم تأثیر بگذارد، زیرا کار به موقع یا در سطح مورد نیاز انجام نمی‌شود. احساسات بد (bad feelings) بین بازبینی‌کننده و بازبینی‌شونده نیز توسط تیم احساس خواهد شد، و یک فضای سرکوب‌گرانه (oppressive atmosphere) که به طور منفی بر همه اعضای تیم تأثیر می‌گذارد، می‌تواند به دنبال داشته باشد. این می‌تواند منجر به دلسردی (demotivated) سایر همکاران شود، و پروژه کلی در نتیجه متحمل ضرر (suffering) شود.

در نهایت، کار به جایی می‌رسد که بازبینی‌شونده به ستوه آمده و برای یک موقعیت جدید در جای دیگری، برای رهایی از همه این‌ها، آنجا را ترک می‌کند. سپس پروژه از نظر زمانی (time-wise) و حتی مالی (financially) متحمل ضرر می‌شود، زیرا زمان و پول باید برای یافتن یک جایگزین (replacement) صرف شود. هر کسی که برای پر کردن موقعیت پیدا می‌شود، باید در مورد سیستم و رویه ها و دستورالعمل‌های کاری (working procedures and guidelines) آموزش ببیند. دیاگرام زیر بازخورد منفی از بازبینی‌کننده به سمت بازبینی‌شونده را نشان می‌دهد:

<div align="center">  
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-8.png) 
</div>

برعکس، بازخورد مثبت (positive feedback) از بازبینی‌کننده به بازبینی‌شونده تأثیر متضادی دارد. هنگامی که بازبینی‌کننده بازخورد مثبت به بازبینی‌شونده می‌دهد، آن‌ها بر مشکل (problem) و نه بر شخص تمرکز می‌کنند. آن‌ها توضیح می‌دهند که چرا کد ارسالی خوب نیست، همراه با مشکلاتی که می‌تواند ایجاد کند. سپس بازبینی‌کننده راه‌هایی را برای بهبود کد به بازبینی‌شونده پیشنهاد می‌کند. بازخورد ارائه شده توسط بازبینی‌کننده فقط برای بهبود کیفیت کد (improve the quality of the code) ارسالی توسط بازبینی‌شونده انجام می‌شود.

هنگامی که بازبینی‌شونده بازخورد مثبت (سازنده) (positive (constructive) feedback) را دریافت می‌کند، به شیوه‌ای مثبت پاسخ می‌دهد. آن‌ها نظرات بازبینی‌کننده (reviewer's comments) را می‌پذیرند و به شیوه مناسب با پاسخ دادن به هر سوالی، پرسیدن هر سوال مرتبطی توسط خودشان، و سپس کد بر اساس بازخورد بازبینی‌کننده به‌روزرسانی (updated) می‌شود. کد اصلاح‌شده (amended) سپس برای بازبینی و پذیرش دوباره ارسال (resubmitted) می‌شود. این امر تأثیر مثبتی (positive impact) بر تیم دارد زیرا جو (atmosphere) مثبت باقی می‌ماند، و کار به موقع و با کیفیت مورد نیاز (required quality) انجام می‌شود.

دیاگرام زیر نتایج بازخورد مثبت از بازبینی‌کننده به بازبینی‌شونده را نشان می‌دهد:

<div align="center">  
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-9.png) 
</div>

نکته‌ای که باید به خاطر بسپارید این است که بازخورد شما می‌تواند سازنده (constructive) یا مخرب (destructive) باشد. هدف شما به عنوان یک بازبینی‌کننده این است که سازنده باشید و نه مخرب. یک تیم شاد، یک تیم مولد (productive) است. یک تیم دلسرد (demoralized) مولد نیست و برای پروژه مضر (damaging) است. بنابراین، همیشه تلاش کنید تا از طریق بازخورد مثبت، تیمی شاد را حفظ کنید.

یک تکنیک برای انتقاد مثبت (positive criticism)، تکنیک ساندویچ بازخورد (feedback sandwich technique) است. شما با تمجید (praise) از نکات خوب شروع می‌کنید، سپس انتقاد سازنده (constructive criticism) را ارائه می‌دهید، و سپس با تمجید بیشتر (further praise) به پایان می‌رسانید. این تکنیک می‌تواند بسیار مفید باشد اگر اعضایی در تیم خود دارید که به هیچ شکلی از انتقاد واکنش خوبی نشان نمی‌دهند. مهارت‌های نرم (soft skills) شما در برخورد با مردم به همان اندازه مهارت‌های نرم‌افزاری (software skills) شما در ارائه کد با کیفیت (quality code) مهم است. این را فراموش نکنید!

اکنون به بررسی اینکه چه چیزی را باید بازبینی کنیم، می‌پردازیم.

## دانستن اینکه چه چیزی را بازبینی کنیم (Knowing what to review)
هنگام بازبینی کد، جنبه‌های مختلفی از کد باید در نظر گرفته شوند. در وهله اول، کد در حال بازبینی فقط باید کدی باشد که توسط برنامه‌نویس تغییر یافته و برای بازبینی ارسال شده است. به همین دلیل باید سعی کنید ارسال‌های کوچک (small submissions) را اغلب انجام دهید. مقادیر کم کد بسیار آسان‌تر برای بازبینی و نظر دادن هستند.

بیایید جنبه‌های مختلفی را که یک بازبینی‌کننده کد باید برای یک بازبینی کامل و دقیق ارزیابی کند، مرور کنیم.

## دستورالعمل‌های کدنویسی شرکت و الزامات تجاری
تمام کدهای در حال بازبینی باید در برابر دستورالعمل‌های کدنویسی شرکت (company's coding guidelines) و الزامات تجاری (business requirement(s)) که کد به آن می‌پردازد، بررسی شوند. تمام کدهای جدید باید به آخرین استانداردهای کدنویسی (coding standards) و بهترین شیوه‌های (best practices) مورد استفاده شرکت پایبند باشند.

انواع مختلفی از الزامات تجاری وجود دارد. این الزامات شامل الزامات کسب و کار (business) و کاربر/ذینفع (user/stakeholder) و همچنین الزامات عملکردی (functional) و پیاده‌سازی (implementation) هستند. صرف نظر از نوع الزامی که کد به آن می‌پردازد، باید به طور کامل از نظر صحت (correctness) در برآورده کردن الزامات بررسی شود.

به عنوان مثال، اگر الزام کاربر/ذینفع بیان می‌کند که به عنوان یک کاربر، می‌خواهم یک حساب مشتری جدید اضافه کنم، آیا کد تحت بازبینی تمام شرایط تعیین شده در این الزام را برآورده می‌کند؟ اگر دستورالعمل‌های کدنویسی شرکت تصریح می‌کنند که تمام کدها باید شامل تست‌های واحد (unit tests) باشند که جریان عادی و موارد استثنایی را تست می‌کنند، آیا تمام تست‌های مورد نیاز پیاده‌سازی شده‌اند؟ اگر پاسخ به هر یک از این سوالات منفی است، باید روی کد نظر داده شود، نظرات توسط برنامه‌نویس برطرف شوند و کد دوباره ارسال شود.

## قراردادهای نام‌گذاری
کد باید بررسی شود تا مشخص شود آیا قراردادهای نام‌گذاری (naming conventions) برای ساختارهای مختلف کد (various code constructs)، مانند کلاس‌ها (classes)، رابط‌ها (interfaces)، متغیرهای عضو (member variables)، متغیرهای محلی (local variables)، شمارش‌ها (enumerations)، و متدها (methods) رعایت شده‌اند یا خیر. هیچ کس نام‌های مبهم (cryptic names) را که رمزگشایی آن‌ها دشوار است، دوست ندارد، به خصوص اگر پایگاه کد (code base) بزرگ باشد.

در اینجا چند سوال وجود دارد که یک بازبینی‌کننده باید بپرسد:

+ آیا نام‌ها به اندازه کافی بلند هستند که خوانا (human-readable) و قابل درک باشند؟

+ آیا آن‌ها در رابطه با هدف کد (intent of the code) معنی‌دار هستند، اما به اندازه کافی کوتاه هستند که سایر برنامه‌نویسان را آزار ندهند (not irritate)؟

به عنوان بازبینی‌کننده، شما باید بتوانید کد را بخوانید و درک کنید. اگر خواندن و درک کد دشوار است، پس واقعاً باید قبل از ادغام بازسازی (refactored) شود.

## قالب‌بندی
قالب‌بندی (Formatting) کمک زیادی به آسان کردن درک کد می‌کند. فضاهای نام (Namespaces)، آکولادها (braces)، و تورفتگی (indentation) باید طبق دستورالعمل‌ها به کار گرفته شوند، و شروع و پایان بلوک‌های کد (code blocks) باید به راحتی قابل شناسایی باشند.

دوباره، در اینجا مجموعه‌ای از سوالات وجود دارد که یک بازبینی‌کننده باید در بازبینی خود در نظر بگیرد:

+ آیا کد با استفاده از فاصله (spaces) یا تب (tabs) تورفتگی دارد؟

+ آیا مقدار صحیح فضای سفید (white space) به کار گرفته شده است؟

+ آیا خطوط کدی وجود دارند که بیش از حد طولانی هستند و باید به چندین خط تقسیم شوند؟

+ در مورد شکست‌های خط (line breaks) چطور؟

+ با پیروی از دستورالعمل‌های سبک (style guidelines)، آیا فقط یک دستور (statement) در هر خط وجود دارد؟ آیا فقط یک اعلان (declaration) در هر خط وجود دارد؟

+ آیا خطوط ادامه (continuation lines) با استفاده از یک ایستگاه تب (tab stop) به درستی تورفتگی دارند؟

+ آیا متدها با یک خط از هم جدا شده‌اند؟

+ آیا عبارات چندگانه (multiple clauses) که یک عبارت واحد (single expression) را تشکیل می‌دهند با پرانتز (parentheses) از هم جدا شده‌اند؟

+ آیا کلاس‌ها و متدها تمیز (clean) و کوچک (small) هستند، و آیا فقط کاری را انجام می‌دهند که برای آن در نظر گرفته شده‌اند؟

## تست‌نویسی
تست‌ها (Tests) باید قابل درک باشند و زیرمجموعه خوبی از موارد استفاده (use cases) را پوشش دهند. آن‌ها باید مسیرهای عادی اجرا (normal paths of execution) و موارد استفاده استثنایی (exceptional use cases) را پوشش دهند. هنگامی که نوبت به تست کد می‌رسد، بازبینی‌کننده باید موارد زیر را بررسی کند:

+ آیا برنامه‌نویس برای تمام کد تست ارائه کرده است؟

+ آیا کدی وجود دارد که تست نشده (untested) باشد؟

+ آیا تمام تست‌ها کار می‌کنند؟

+ آیا هیچ یک از تست‌ها شکست می‌خورند؟

+ آیا مستندات کافی (adequate documentation) از کد، شامل نظرات (comments)، نظرات مستندات (documentation comments)، تست‌ها، و مستندات محصول (product documentation) وجود دارد؟

+ آیا چیزی برجسته می‌بینید که، حتی اگر کامپایل شود و در انزوا (isolation) کار کند، می‌تواند هنگام ادغام در سیستم (integrated into the system) باعث باگ (bugs) شود؟

+ آیا کد برای کمک به نگهداری (maintenance) و پشتیبانی (support) به خوبی مستند شده است؟

بیایید ببینیم فرآیند چگونه پیش می‌رود:

<div align="center">  
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-10.png) 
</div>

کد تست نشده (Untested code) این پتانسیل را دارد که در طول تست‌نویسی (testing) و تولید (production)، استثنائات غیرمنتظره‌ای (unexpected exceptions) را مطرح کند. اما به همان بدی کدی که تست نشده است، تست‌هایی هستند که صحیح نیستند. این می‌تواند منجر به باگ‌هایی (bugs) شود که تشخیص آن‌ها دشوار است، می‌تواند برای مشتری آزاردهنده باشد، و در آینده کار بیشتری برای شما ایجاد کند. باگ‌ها بدهی فنی (technical debt) هستند و از نظر کسب و کار به آن‌ها منفی نگاه می‌شود. علاوه بر این، ممکن است شما کد را نوشته باشید، اما دیگران ممکن است مجبور باشند آن را بخوانند زیرا پروژه را نگهداری (maintain) و گسترش (extend) می‌دهند. همیشه ایده خوبی است که مستنداتی (documentation) برای همکاران خود ارائه دهید.

اکنون، در مورد مشتری، آن‌ها چگونه قرار است بفهمند که ویژگی‌های (features) شما کجاست و چگونه از آن‌ها استفاده کنند؟ مستندات خوب و کاربرپسند (user-friendly) ایده خوبی است. و به یاد داشته باشید، همه کاربران شما ممکن است از نظر فنی با‌سواد (technically savvy) نباشند. بنابراین، به افراد کم‌مهارت‌تر که ممکن است به راهنمایی (handholding) نیاز داشته باشند، توجه کنید، اما این کار را بدون تحقیر (patronizing) انجام دهید.

به عنوان یک مرجع فنی (technical authority) که کد را بازبینی می‌کند، آیا بوی کد (code smells) را که ممکن است به یک مشکل تبدیل شود، تشخیص می‌دهید؟ اگر چنین است، باید درخواست کشیدن را پرچم‌گذاری (flag)، نظردهی (comment) و رد (reject) کنید و از برنامه‌نویس بخواهید کار خود را دوباره ارسال (resubmit) کند.

به عنوان یک بازبینی‌کننده، باید بررسی کنید که از آن استثنائات (exceptions) برای کنترل جریان برنامه (program flow) استفاده نمی‌شود و هر خطایی که مطرح می‌شود پیام‌های معنی‌داری (meaningful messages) دارد که برای توسعه‌دهندگان و مشتریانی که آن‌ها را دریافت خواهند کرد، مفید است.

## دستورالعمل‌های معماری و الگوهای طراحی (Architectural guidelines and design patterns)
کد جدید باید بررسی شود تا مشخص شود آیا با دستورالعمل‌های معماری (architectural guidelines) پروژه مطابقت دارد یا خیر. کد باید از هرگونه پارادایم کدنویسی (coding paradigms) که شرکت به کار می‌گیرد، مانند SOLID، DRY، YAGNI، و OOP (برنامه‌نویسی شی‌گرا)، پیروی کند. علاوه بر این، در صورت امکان، کد باید از الگوهای طراحی مناسب (suitable design patterns) استفاده کند.

اینجاست که الگوهای گنگ چهار نفره (Gang-of-Four (GoF) patterns) وارد عمل می‌شوند. GoF شامل چهار نویسنده کتاب C++ به نام Design Patterns: Elements of Reusable Object-Oriented Software است. نویسندگان اریش گاما، ریچارد هلم، رالف جانسون و جان ولسیدس بودند. امروزه، الگوهای طراحی آن‌ها به شدت در اکثر، اگر نگوییم تمام، زبان‌های برنامه‌نویسی شی‌گرا (object-oriented programming languages) استفاده می‌شوند. Packt کتاب‌هایی را پوشش می‌دهد که الگوهای طراحی را پوشش می‌دهند، از جمله NET Design Patterns، اثر پراسین پای و شاین خاویر. در اینجا یک منبع واقعاً خوب را توصیه می‌کنم که از آن بازدید کنید: https://www.dofactory.com/net/design-patterns. این سایت هر یک از الگوهای GoF را پوشش می‌دهد و تعریف، دیاگرام کلاس UML (UML class diagram)، شرکت‌کنندگان (participants)، کد ساختاری (structural code)، و برخی کد دنیای واقعی (real-world code) برای الگوها را ارائه می‌دهد.

الگوهای GoF شامل الگوهای طراحی سازنده (creational design patterns)، ساختاری (structural) و رفتاری (behavioral) هستند. الگوهای طراحی سازنده شامل کارخانه انتزاعی (Abstract Factory)، سازنده (Builder)، متد کارخانه (Factory Method)، نمونه اولیه (Prototype)، و تک‌نمونه (Singleton) هستند. الگوهای طراحی ساختاری شامل آداپتور (Adapter)، پل (Bridge)، کامپوزیت (Composite)، دکوراتور (Decorator)، نما (Façade)، فلای‌ویت (Flyweight)، و پروکسی (Proxy) هستند. الگوهای طراحی رفتاری شامل زنجیره مسئولیت (Chain of Responsibility)، دستور (Command)، مفسر (Interpreter)، تکرارکننده (Iterator)، واسطه (Mediator)، یادگار (Memento)، ناظر (Observer)، حالت (State)، استراتژی (Strategy)، متد الگو (Template Method)، و بازدیدکننده (Visitor) هستند.

کد همچنین باید به درستی سازماندهی (organized) شود و در فضای نام (namespace) و ماژول (module) صحیح قرار گیرد. همچنین کد را بررسی کنید تا ببینید آیا بیش از حد ساده‌انگارانه (simplistic) است یا بیش از حد مهندسی شده (over-engineered).

## عملکرد و امنیت (Performance and security)
سایر مواردی که ممکن است نیاز به بررسی داشته باشند شامل عملکرد (performance) و امنیت (security) هستند:

+ کد چقدر خوب عملکرد (perform) دارد؟

+ آیا هیچ محدودیتی (bottlenecks) وجود دارد که باید برطرف شود؟

+ آیا کد به گونه‌ای برنامه‌ریزی شده است که در برابر حملات تزریق SQL (SQL injection attacks) و حملات محروم‌سازی از سرویس (denial-of-service attacks) محافظت کند؟

+ آیا کد به درستی اعتبارسنجی (validated) شده است تا داده‌ها تمیز بمانند و فقط داده‌های معتبر (valid data) در پایگاه داده (database) ذخیره شوند؟

+ آیا رابط کاربری (user interface)، مستندات (documentation)، و پیام‌های خطا (error messages) را برای اشتباهات املایی (spelling mistakes) بررسی کرده‌اید؟

+ آیا با هیچ اعداد جادویی (magic numbers) یا مقادیر کدگذاری شده سخت (hard coded values) مواجه شده‌اید؟

+ آیا داده‌های پیکربندی (configuration data) صحیح است؟

+ آیا هیچ راز (secrets) به طور تصادفی چک‌این (checked in) شده است؟

یک بازبینی جامع کد (comprehensive code review) شامل تمام جنبه‌های پیشین و پارامترهای بازبینی مربوطه آن‌ها خواهد بود. اما بیایید بفهمیم که چه زمانی واقعاً زمان مناسب برای انجام بازبینی کد است.

## دانستن زمان ارسال کد برای بازبینی (Knowing when to send code for review)
بازبینی‌های کد (Code reviews) باید زمانی انجام شوند که توسعه (development) کامل شده باشد و قبل از اینکه برنامه‌نویس کد را به بخش کنترل کیفیت (QA department) منتقل کند. قبل از اینکه هر کدی در کنترل نسخه (version control) چک‌این شود، تمام کد باید بدون خطا، هشدار یا اطلاعات بیلد (build) شود و اجرا شود. می‌توانید این را با انجام کارهای زیر تضمین کنید:

+ باید تحلیل کد استاتیک (static code analysis) را بر روی برنامه‌های خود اجرا کنید تا ببینید آیا مشکلی مطرح می‌شود یا خیر. اگر خطا، هشدار یا اطلاعاتی دریافت کردید، هر نکته مطرح شده را برطرف کنید. آن‌ها را نادیده نگیرید زیرا می‌توانند در آینده مشکل ایجاد کنند. می‌توانید به دیالوگ پیکربندی تحلیل کد (Code Analysis configuration dialog) در صفحه تحلیل کد (Code Analysis) از تب ویژگی‌های پروژه Visual Studio 2019 (Visual Studio 2019 Project Properties tab) دسترسی پیدا کنید. روی پروژه خود راست کلیک کرده و Properties | Code Analysis را انتخاب کنید.

+ همچنین باید مطمئن شوید که تمام تست‌های شما با موفقیت اجرا می‌شوند، و باید هدف داشته باشید که تمام کد جدید شما به طور کامل توسط موارد استفاده عادی (normal use cases) و استثنایی (exceptional use cases) پوشش داده شود که صحت (correctness) کد شما را در برابر مشخصاتی (specification) که روی آن کار می‌کنید، تست می‌کند.

+ اگر یک شیوه نرم‌افزاری توسعه مداوم (continuous development software practice) را در محل کار خود به کار می‌گیرید که کد شما را در یک سیستم بزرگتر ادغام می‌کند، باید مطمئن شوید که یکپارچه‌سازی سیستم (system integration) موفقیت‌آمیز است و تمام تست‌ها بدون شکست اجرا می‌شوند. اگر خطایی مواجه شد، باید قبل از ادامه آن‌ها را برطرف کنید.

هنگامی که کد شما کامل، به طور کامل مستند (documented)، و تست‌های شما کار می‌کنند، و یکپارچه‌سازی سیستم (system integration) شما بدون هیچ مشکلی کار می‌کند، آن زمان بهترین زمان برای انجام یک بازبینی کد همتا (peer code review) است. هنگامی که به نقطه‌ای رسیدید که بازبینی کد همتای شما تأیید شد، کد شما می‌تواند به بخش کنترل کیفیت (QA department) منتقل شود. دیاگرام زیر چرخه عمر توسعه نرم‌افزار (Software Development Life Cycle (SDLC)) را از توسعه کد تا پایان عمر کد نشان می‌دهد:

<div align="center">  
  
  ![Conventions-UsedThis-Book](../../assets/image/02/Table%202-11.png) 
</div>
